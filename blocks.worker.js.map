{"version":3,"file":"blocks.worker.js","sources":["../src/workers/blocks.js"],"sourcesContent":["// eslint-disable-next-line no-restricted-globals\nconst context = self;\n\nconst size = 16;\nconst subchunks = 5;\nconst maxHeight = size * subchunks;\nconst maxLight = 15;\nconst fields = {\n  type: 0,\n  light1: 1,\n  light2: 2,\n  light3: 3,\n  sunlight: 4,\n  count: 5,\n};\nconst textureWidth = 16;\nconst textureHeight = 16;\n\nconst chunks = new Map();\nconst lightChannels = {\n  light1: { r: 1, g: 1, b: 1 },\n  light2: { r: 1, g: 1, b: 1 },\n  light3: { r: 1, g: 1, b: 1 },\n  sunlight: { r: 1, g: 1, b: 1 },\n};\nlet types;\n\nconst allocate = (cx, cz) => {\n  const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n  const heightmap = new Uint8ClampedArray(size ** 2);\n  return {\n    x: cx,\n    z: cz,\n    voxels,\n    heightmap,\n    hasPropagated: false,\n  };\n};\n\nconst getChunk = (cx, cz) => {\n  const key = `${cx}:${cz}`;\n  let chunk = chunks.get(key);\n  if (!chunk) {\n    chunk = {\n      ...allocate(cx, cz),\n      key,\n    };\n    chunks.set(key, chunk);\n  }\n  return chunk;\n};\n\nconst getIndex = (x, y, z) => (\n  ((x * size * maxHeight) + (y * size) + z) * fields.count\n);\n\nconst getVoxelChunk = (origin) => (x, z) => {\n  let chunk = origin;\n  const nx = (x < 0 || x >= size) ? Math.floor(x / size) : 0;\n  const nz = (z < 0 || z >= size) ? Math.floor(z / size) : 0;\n  if (nx || nz) {\n    chunk = getChunk(origin.x + nx, origin.z + nz);\n    x -= size * nx;\n    z -= size * nz;\n  }\n  return { chunk, cx: x, cz: z };\n};\n\nconst voxelNeighbors = [\n  { x: 1, y: 0, z: 0 },\n  { x: -1, y: 0, z: 0 },\n  { x: 0, y: 0, z: 1 },\n  { x: 0, y: 0, z: -1 },\n  { x: 0, y: 1, z: 0 },\n  { x: 0, y: -1, z: 0 },\n];\nconst floodLight = (origin, queue, key) => {\n  const getChunk = getVoxelChunk(origin);\n  const isSunLight = key === 'sunlight';\n  const isTranslucent = (type) => types[type].isTranslucent;\n  while (queue.length) {\n    const { x, y, z } = queue.shift();\n    const { chunk, cx, cz } = getChunk(x, z);\n    const light = chunk.voxels[\n      getIndex(cx, y, cz) + fields[key]\n    ];\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const nl = light - ((isSunLight && offset.y === -1 && light === maxLight) ? 0 : 1);\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      if (\n        !isTranslucent(chunk.voxels[voxel])\n        || (\n          isSunLight\n          && offset.y !== -1\n          && light === maxLight\n          && ny > chunk.heightmap[(cx * size) + cz]\n        )\n        || chunk.voxels[voxel + fields[key]] >= nl\n      ) {\n        return;\n      }\n      chunk.voxels[voxel + fields[key]] = nl;\n      queue.push({ x: nx, y: ny, z: nz });\n    });\n  }\n};\n\nconst propagate = (chunk) => {\n  const lightQueues = [[], [], []];\n  const sunlightQueue = [];\n  const top = maxHeight - 1;\n  for (let x = 0; x < size; x += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      for (let z = 0; z < size; z += 1) {\n        const i = getIndex(x, y, z);\n        const type = chunk.voxels[i];\n        if (y === top && types[type].isTranslucent) {\n          chunk.voxels[i + fields.sunlight] = maxLight;\n          sunlightQueue.push({ x, y: top, z });\n        } else if (types[type].light) {\n          chunk.voxels[i + fields[`light${types[type].light}`]] = maxLight;\n          lightQueues[types[type].light - 1].push({ x, y, z });\n        }\n      }\n    }\n  }\n  floodLight(chunk, lightQueues[0], 'light1');\n  floodLight(chunk, lightQueues[1], 'light2');\n  floodLight(chunk, lightQueues[2], 'light3');\n  floodLight(chunk, sunlightQueue, 'sunlight');\n  chunk.hasPropagated = true;\n};\n\nconst removeLight = (origin, x, y, z, key) => {\n  const getChunk = getVoxelChunk(origin);\n  const { chunk, cx, cz } = getChunk(x, z);\n  const voxel = getIndex(cx, y, cz);\n  const fill = [];\n  const queue = [];\n  queue.push({\n    x,\n    y,\n    z,\n    light: chunk.voxels[voxel + fields[key]],\n  });\n  chunk.voxels[voxel + fields[key]] = 0;\n  const isSunLight = key === 'sunlight';\n  while (queue.length) {\n    const {\n      x,\n      y,\n      z,\n      light,\n    } = queue.shift();\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      const nl = chunk.voxels[voxel + fields[key]];\n      if (nl === 0) {\n        return;\n      }\n      if (\n        nl < light\n        || (\n          isSunLight\n          && offset.y === -1\n          && light === maxLight\n          && nl === maxLight\n        )\n      ) {\n        queue.push({\n          x: nx,\n          y: ny,\n          z: nz,\n          light: nl,\n        });\n        chunk.voxels[voxel + fields[key]] = 0;\n      } else if (nl >= light) {\n        fill.push({\n          x: nx,\n          y: ny,\n          z: nz,\n        });\n      }\n    });\n  }\n  floodLight(origin, fill, key);\n};\n\nconst update = ({\n  x,\n  y,\n  z,\n  type,\n}) => {\n  const chunk = getChunk(\n    Math.floor(x / size),\n    Math.floor(z / size)\n  );\n  x -= size * chunk.x;\n  z -= size * chunk.z;\n  const {\n    heightmap,\n    voxels,\n    hasPropagated,\n  } = chunk;\n  const voxel = getIndex(x, y, z);\n  const current = voxels[voxel];\n  voxels[voxel] = type;\n  const heightIndex = (x * size) + z;\n  const height = heightmap[heightIndex];\n  if (type === types.air) {\n    if (y === height) {\n      for (let i = y - 1; i >= 0; i -= 1) {\n        if (i === 0 || voxels[getIndex(x, i, z)] !== 0) {\n          heightmap[heightIndex] = i;\n          break;\n        }\n      }\n    }\n  } else if (height < y) {\n    heightmap[heightIndex] = y;\n  }\n  if (hasPropagated) {\n    if (types[current].light) {\n      removeLight(chunk, x, y, z, `light${types[current].light}`);\n    } else if (types[current].isTranslucent && !types[type].isTranslucent) {\n      ['light1', 'light2', 'light3', 'sunlight'].forEach((key) => {\n        if (voxels[voxel + fields[key]] !== 0) {\n          removeLight(chunk, x, y, z, key);\n        }\n      });\n    }\n    if (types[type].light) {\n      const key = `light${types[type].light}`;\n      voxels[voxel + fields[key]] = maxLight;\n      floodLight(chunk, [{ x, y, z }], key);\n    } else if (types[type].isTranslucent && !types[current].isTranslucent) {\n      const getChunk = getVoxelChunk(chunk);\n      ['light1', 'light2', 'light3', 'sunlight'].forEach((key) => {\n        const queue = [];\n        if (key === 'sunlight' && y === maxHeight - 1) {\n          voxels[voxel + fields[key]] = maxLight;\n          queue.push({ x, y, z });\n        } else {\n          voxelNeighbors.forEach((offset) => {\n            const ny = y + offset.y;\n            if (ny < 0 || ny >= maxHeight) {\n              return;\n            }\n            const nx = x + offset.x;\n            const nz = z + offset.z;\n            const { chunk, cx, cz } = getChunk(nx, nz);\n            const voxel = getIndex(cx, ny, cz);\n            const { light, isTranslucent } = types[chunk.voxels[voxel]];\n            if (\n              chunk.voxels[voxel + fields[key]] !== 0\n              && (isTranslucent || (light && key !== 'sunlight'))\n            ) {\n              queue.push({ x: nx, y: ny, z: nz });\n            }\n          });\n        }\n        floodLight(chunk, queue, key);\n      });\n    }\n  }\n  return chunk;\n};\n\nconst clone = ({ x, y, z }, to) => {\n  const chunk = getChunk(\n    Math.floor(x / size),\n    Math.floor(z / size)\n  );\n  x -= size * chunk.x;\n  z -= size * chunk.z;\n  return update({\n    ...to,\n    type: chunk.voxels[getIndex(x, y, z)],\n  });\n};\n\nconst getLightColor = (l1, l2, l3, s, ao = 1) => {\n  const color = ['r', 'g', 'b'].reduce((color, key) => {\n    color[key] = Math.max(\n      Math.min(\n        (\n          l1 ** 2 * lightChannels.light1[key]\n          + l2 ** 2 * lightChannels.light2[key]\n          + l3 ** 2 * lightChannels.light3[key]\n          + s ** 2 * lightChannels.sunlight[key]\n        ),\n        1\n      ),\n      0.02\n    ) * ao;\n    return color;\n  }, {});\n  color.avg = (color.r + color.g + color.b) / 3;\n  return color;\n};\n\nconst getLighting = (\n  {\n    light1,\n    light2,\n    light3,\n    sunlight,\n  },\n  neighbors\n) => neighbors.map((neighbors) => {\n  let n1 = types[neighbors[0].type].hasAO;\n  let n2 = types[neighbors[1].type].hasAO;\n  let n3 = (n1 && n2) || types[neighbors[2].type].hasAO;\n  const ao = [n1, n2, n3].reduce((ao, n) => (\n    ao - (n ? 0.1 : 0)\n  ), 1);\n  let c = 1;\n  let l1 = light1;\n  let l2 = light2;\n  let l3 = light3;\n  let s = sunlight;\n  n1 = types[neighbors[0].type].isTranslucent;\n  n2 = types[neighbors[1].type].isTranslucent;\n  n3 = (n1 || n2) && types[neighbors[2].type].isTranslucent;\n  [n1, n2, n3].forEach((n, i) => {\n    if (n) {\n      l1 += neighbors[i].light1;\n      l2 += neighbors[i].light2;\n      l3 += neighbors[i].light3;\n      s += neighbors[i].sunlight;\n      c += 1;\n    }\n  });\n  l1 = l1 / c / maxLight;\n  l2 = l2 / c / maxLight;\n  l3 = l3 / c / maxLight;\n  s = s / c / maxLight;\n  return getLightColor(l1, l2, l3, s, ao);\n});\n\nconst edges = {\n  top: {\n    type: 0,\n    light1: 0,\n    light2: 0,\n    light3: 0,\n    sunlight: maxLight,\n  },\n  bottom: {\n    type: 0,\n    light1: 0,\n    light2: 0,\n    light3: 0,\n    sunlight: 0,\n  },\n};\nconst getVoxelData = (origin) => {\n  const getChunk = getVoxelChunk(origin);\n  return (x, y, z) => {\n    if (y < 0) {\n      return edges.bottom;\n    }\n    if (y >= maxHeight) {\n      return edges.top;\n    }\n    const { chunk, cx, cz } = getChunk(x, z);\n    const i = getIndex(cx, y, cz);\n    return {\n      type: chunk.voxels[i],\n      light1: chunk.voxels[i + fields.light1],\n      light2: chunk.voxels[i + fields.light2],\n      light3: chunk.voxels[i + fields.light3],\n      sunlight: chunk.voxels[i + fields.sunlight],\n    };\n  };\n};\n\nconst isVisible = (type, neighbor) => (\n  (types[type].isGhost || !types[neighbor].isGhost)\n  && (\n    !types[type].isCulled\n    || !types[neighbor].isCulled\n    || (\n      (types[neighbor].hasAlpha || types[neighbor].hasBlending)\n      && (\n        !(types[type].hasAlpha || types[type].hasBlending)\n        || type !== neighbor\n      )\n    )\n  )\n);\n\nconst chunkNeighbors = [\n  { x: -1, z: -1 },\n  { x: 0, z: -1 },\n  { x: 1, z: -1 },\n  { x: -1, z: 0 },\n  { x: 1, z: 0 },\n  { x: -1, z: 1 },\n  { x: 0, z: 1 },\n  { x: 1, z: 1 },\n];\nconst textureY = {\n  from: 1 / (textureHeight + 2),\n  to: (textureHeight + 1) / (textureHeight + 2),\n};\nconst meshedChunks = new Map();\nconst mesh = (cx, cz) => {\n  const chunk = getChunk(cx, cz);\n  if (!meshedChunks.has(chunk.key)) {\n    meshedChunks.set(chunk.key, chunk);\n  }\n  if (!chunk.hasPropagated) {\n    propagate(chunk);\n  }\n  chunkNeighbors.forEach(({ x, z }) => {\n    const neighbor = getChunk(chunk.x + x, chunk.z + z);\n    if (!neighbor.hasPropagated) {\n      propagate(neighbor);\n    }\n  });\n  const get = getVoxelData(chunk);\n  return [...Array(subchunks)].map((v, subchunk) => {\n    const geometry = ['alpha', 'blending', 'ghost', 'opaque'].reduce((meshes, key) => {\n      meshes[key] = {\n        color: [],\n        position: [],\n        uv: [],\n        index: [],\n        offset: 0,\n      };\n      return meshes;\n    }, {});\n    const pushFace = (\n      p1,\n      p2,\n      p3,\n      p4,\n      type,\n      lighting,\n      facing\n    ) => {\n      const texture = types[type].textures[facing % 6];\n      const uvs = [\n        [texture.from, facing + textureY.to],\n        [texture.to, facing + textureY.to],\n        [texture.to, facing + textureY.from],\n        [texture.from, facing + textureY.from],\n      ];\n      const vertices = [p1, p2, p3, p4];\n      if (lighting[0].avg + lighting[2].avg < lighting[1].avg + lighting[3].avg) {\n        lighting.unshift(lighting.pop());\n        uvs.unshift(uvs.pop());\n        vertices.unshift(vertices.pop());\n      }\n      let mesh = geometry.opaque;\n      if (types[type].hasAlpha) {\n        mesh = geometry.alpha;\n      } else if (types[type].hasBlending) {\n        mesh = geometry.blending;\n      } else if (types[type].isGhost) {\n        mesh = geometry.ghost;\n      }\n      lighting.forEach((light) => mesh.color.push(light.r, light.g, light.b));\n      uvs.forEach((uv) => mesh.uv.push(...uv));\n      vertices.forEach((vertex) => mesh.position.push(...vertex));\n      [0, 1, 2, 2, 3, 0].forEach((i) => mesh.index.push(mesh.offset + i));\n      mesh.offset += 4;\n    };\n    const box = (x, y, z, type) => {\n      const top = get(x, y + 1, z);\n      const bottom = get(x, y - 1, z);\n      const south = get(x, y, z + 1);\n      const north = get(x, y, z - 1);\n      const west = get(x - 1, y, z);\n      const east = get(x + 1, y, z);\n      if (isVisible(type, top.type)) {\n        const n = get(x, y + 1, z - 1);\n        const e = get(x + 1, y + 1, z);\n        const w = get(x - 1, y + 1, z);\n        const s = get(x, y + 1, z + 1);\n        pushFace(\n          [x, y + 1, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x + 1, y + 1, z],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            top,\n            [\n              [w, s, get(x - 1, y + 1, z + 1)],\n              [e, s, get(x + 1, y + 1, z + 1)],\n              [e, n, get(x + 1, y + 1, z - 1)],\n              [w, n, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          0\n        );\n      }\n      if (isVisible(type, bottom.type)) {\n        const n = get(x, y - 1, z - 1);\n        const e = get(x + 1, y - 1, z);\n        const w = get(x - 1, y - 1, z);\n        const s = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z],\n          [x + 1, y, z],\n          [x + 1, y, z + 1],\n          [x, y, z + 1],\n          type,\n          getLighting(\n            bottom,\n            [\n              [w, n, get(x - 1, y - 1, z - 1)],\n              [e, n, get(x + 1, y - 1, z - 1)],\n              [e, s, get(x + 1, y - 1, z + 1)],\n              [w, s, get(x - 1, y - 1, z + 1)],\n            ]\n          ),\n          1\n        );\n      }\n      if (isVisible(type, south.type)) {\n        const e = get(x + 1, y, z + 1);\n        const w = get(x - 1, y, z + 1);\n        const t = get(x, y + 1, z + 1);\n        const b = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z + 1],\n          [x + 1, y, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x, y + 1, z + 1],\n          type,\n          getLighting(\n            south,\n            [\n              [w, b, get(x - 1, y - 1, z + 1)],\n              [e, b, get(x + 1, y - 1, z + 1)],\n              [e, t, get(x + 1, y + 1, z + 1)],\n              [w, t, get(x - 1, y + 1, z + 1)],\n            ]\n          ),\n          2\n        );\n      }\n      if (isVisible(type, north.type)) {\n        const e = get(x + 1, y, z - 1);\n        const w = get(x - 1, y, z - 1);\n        const t = get(x, y + 1, z - 1);\n        const b = get(x, y - 1, z - 1);\n        pushFace(\n          [x + 1, y, z],\n          [x, y, z],\n          [x, y + 1, z],\n          [x + 1, y + 1, z],\n          type,\n          getLighting(\n            north,\n            [\n              [e, b, get(x + 1, y - 1, z - 1)],\n              [w, b, get(x - 1, y - 1, z - 1)],\n              [w, t, get(x - 1, y + 1, z - 1)],\n              [e, t, get(x + 1, y + 1, z - 1)],\n            ]\n          ),\n          3\n        );\n      }\n      if (isVisible(type, west.type)) {\n        const n = get(x - 1, y, z - 1);\n        const s = get(x - 1, y, z + 1);\n        const t = get(x - 1, y + 1, z);\n        const b = get(x - 1, y - 1, z);\n        pushFace(\n          [x, y, z],\n          [x, y, z + 1],\n          [x, y + 1, z + 1],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            west,\n            [\n              [n, b, get(x - 1, y - 1, z - 1)],\n              [s, b, get(x - 1, y - 1, z + 1)],\n              [s, t, get(x - 1, y + 1, z + 1)],\n              [n, t, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          4\n        );\n      }\n      if (isVisible(type, east.type)) {\n        const n = get(x + 1, y, z - 1);\n        const s = get(x + 1, y, z + 1);\n        const t = get(x + 1, y + 1, z);\n        const b = get(x + 1, y - 1, z);\n        pushFace(\n          [x + 1, y, z + 1],\n          [x + 1, y, z],\n          [x + 1, y + 1, z],\n          [x + 1, y + 1, z + 1],\n          type,\n          getLighting(\n            east,\n            [\n              [s, b, get(x + 1, y - 1, z + 1)],\n              [n, b, get(x + 1, y - 1, z - 1)],\n              [n, t, get(x + 1, y + 1, z - 1)],\n              [s, t, get(x + 1, y + 1, z + 1)],\n            ]\n          ),\n          5\n        );\n      }\n    };\n    const cross = (\n      x, y, z,\n      {\n        type,\n        light1,\n        light2,\n        light3,\n        sunlight,\n      },\n      doubleSide\n    ) => {\n      const lighting = (() => {\n        const l1 = light1 / maxLight;\n        const l2 = light2 / maxLight;\n        const l3 = light3 / maxLight;\n        const s = sunlight / maxLight;\n        const lighting = getLightColor(l1, l2, l3, s);\n        return [...Array(4)].map(() => lighting);\n      })();\n      pushFace(\n        [x, y, z],\n        [x + 1, y, z + 1],\n        [x + 1, y + 1, z + 1],\n        [x, y + 1, z],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x, y, z + 1],\n        [x + 1, y, z],\n        [x + 1, y + 1, z],\n        [x, y + 1, z + 1],\n        type,\n        lighting,\n        6\n      );\n      if (doubleSide) {\n        pushFace(\n          [x + 1, y, z + 1],\n          [x, y, z],\n          [x, y + 1, z],\n          [x + 1, y + 1, z + 1],\n          type,\n          lighting,\n          6\n        );\n        pushFace(\n          [x + 1, y, z],\n          [x, y, z + 1],\n          [x, y + 1, z + 1],\n          [x + 1, y + 1, z],\n          type,\n          lighting,\n          6\n        );\n      }\n    };\n    const fromY = subchunk * size;\n    const toY = (subchunk + 1) * size;\n    for (let x = 0; x < size; x += 1) {\n      for (let y = fromY; y < toY; y += 1) {\n        for (let z = 0; z < size; z += 1) {\n          const voxel = get(x, y, z);\n          if (voxel.type !== 0) {\n            switch (types[voxel.type].model) {\n              case 'cross':\n                cross(x, y, z, voxel, !types[voxel.type].hasAlpha);\n                break;\n              default:\n                box(x, y, z, voxel.type);\n                break;\n            }\n          }\n        }\n      }\n    }\n    return ['alpha', 'blending', 'ghost', 'opaque'].reduce((meshes, key) => {\n      const {\n        color,\n        position,\n        uv,\n        index,\n      } = geometry[key];\n      meshes[key] = {\n        color: new Float32Array(color),\n        position: new Uint8Array(position),\n        uv: new Float32Array(uv),\n        index: new Uint16Array(index),\n      };\n      return meshes;\n    }, {});\n  });\n};\n\nconst remesh = (x, z) => {\n  const subchunks = mesh(x, z);\n  context.postMessage({\n    type: 'chunk',\n    position: { x, z },\n    subchunks,\n  }, subchunks.reduce((buffers, meshes) => {\n    ['alpha', 'blending', 'ghost', 'opaque'].forEach((mesh) => {\n      mesh = meshes[mesh];\n      buffers.push(\n        mesh.color.buffer,\n        mesh.position.buffer,\n        mesh.uv.buffer,\n        mesh.index.buffer\n      );\n    });\n    return buffers;\n  }, []));\n};\n\nconst remeshDebounced = (() => {\n  let debounce;\n  const queue = new Map();\n  const remeshQueued = () => {\n    [...queue.values()].forEach((chunk) => (\n      remesh(chunk.x, chunk.z)\n    ));\n    queue.clear();\n  };\n  return (x, z) => {\n    queue.set(`${x}:${z}`, { x, z });\n    if (debounce) {\n      clearTimeout(debounce);\n    }\n    debounce = setTimeout(remeshQueued, 0);\n  };\n})();\n\nconst remeshAll = () => {\n  const list = [...meshedChunks.values()];\n  if (!list.length) {\n    remeshDebounced(0, 0);\n    return;\n  }\n  list.forEach((chunk) => (\n    remeshDebounced(chunk.x, chunk.z)\n  ));\n};\n\nconst computeLightmap = ({ offset = { x: 0, y: 0, z: 0 } }) => {\n  const getLight = (x, y, z) => {\n    const cx = Math.floor(x / size);\n    const cz = Math.floor(z / size);\n    const key = `${cx}:${cz}`;\n    const chunk = meshedChunks.get(key);\n    if (!chunk) {\n      return false;\n    }\n    x -= size * chunk.x;\n    z -= size * chunk.z;\n    const voxel = getIndex(x, y, z);\n    const type = types[chunk.voxels[voxel]];\n    if (!type.isTranslucent) {\n      return false;\n    }\n    return [\n      Math.floor((chunk.voxels[voxel + fields.light1] / maxLight) * 0xFF),\n      Math.floor((chunk.voxels[voxel + fields.light2] / maxLight) * 0xFF),\n      Math.floor((chunk.voxels[voxel + fields.light3] / maxLight) * 0xFF),\n      Math.floor((chunk.voxels[voxel + fields.sunlight] / maxLight) * 0xFF),\n    ];\n  };\n\n  const { min, max } = [...meshedChunks.values()].reduce(({ min, max }, { x, z, heightmap }) => {\n    const height = heightmap.reduce((max, height) => Math.max(max, height), 0);\n    return {\n      min: {\n        x: Math.min(min.x, x * size),\n        y: 0,\n        z: Math.min(min.z, z * size),\n      },\n      max: {\n        x: Math.max(max.x, (x + 1) * size),\n        y: Math.max(max.y, height),\n        z: Math.max(max.z, (z + 1) * size),\n      },\n    };\n  }, {\n    min: { x: Infinity, y: 0, z: Infinity },\n    max: { x: -Infinity, y: 0, z: -Infinity },\n  });\n  max.y = Math.ceil((max.y + size * 0.5) / size) * size;\n\n  const volume = {\n    x: max.x - min.x,\n    y: max.y - min.y,\n    z: max.z - min.z,\n  };\n\n  const lightmap = Array(volume.x * volume.y * volume.z * 4);\n\n  // eslint-disable-next-line prefer-destructuring\n  for (let z = min.z, i = 0; z < max.z; z += 1) {\n    // eslint-disable-next-line prefer-destructuring\n    for (let y = min.y; y < max.y; y += 1) {\n      // eslint-disable-next-line prefer-destructuring\n      for (let x = min.x; x < max.x; x += 1, i += 4) {\n        const light = getLight(x, y, z);\n        for (let j = 0; j < 4; j += 1) {\n          lightmap[i + j] = String.fromCharCode(light ? light[j] : 0);\n        }\n      }\n    }\n  }\n\n  return {\n    channels: [\n      lightChannels.light1,\n      lightChannels.light2,\n      lightChannels.light3,\n      lightChannels.sunlight,\n    ],\n    data: btoa(lightmap.join('')),\n    origin: {\n      x: min.x + offset.x,\n      y: min.y + offset.y,\n      z: min.z + offset.z,\n    },\n    size: volume,\n  };\n};\n\nconst computeOcclusion = ({ includeGhost = true, offset = { x: 0, y: 0, z: 0 } }) => {\n  const hasOcclusion = (x, y, z) => {\n    if (y < 0 || y >= maxHeight) {\n      return false;\n    }\n    const cx = Math.floor(x / size);\n    const cz = Math.floor(z / size);\n    const key = `${cx}:${cz}`;\n    const chunk = meshedChunks.get(key);\n    if (!chunk) {\n      return false;\n    }\n    x -= size * chunk.x;\n    z -= size * chunk.z;\n    const type = chunk.voxels[getIndex(x, y, z)];\n    return type !== 0 && (includeGhost || !types[type].isGhost) && !types[type].isTranslucent;\n  };\n\n  const { min, max } = [...meshedChunks.values()].reduce(({ min, max }, { x, z, heightmap }) => {\n    const height = heightmap.reduce((max, height) => Math.max(max, height), 0);\n    return {\n      min: {\n        x: Math.min(min.x, x * size),\n        y: 0,\n        z: Math.min(min.z, z * size),\n      },\n      max: {\n        x: Math.max(max.x, (x + 1) * size),\n        y: Math.max(max.y, height),\n        z: Math.max(max.z, (z + 1) * size),\n      },\n    };\n  }, {\n    min: { x: Infinity, y: 0, z: Infinity },\n    max: { x: -Infinity, y: 0, z: -Infinity },\n  });\n  max.y = Math.ceil((max.y + size * 0.5) / size) * size;\n\n  const volume = {\n    x: max.x - min.x,\n    y: max.y - min.y,\n    z: max.z - min.z,\n  };\n\n  const occlusionMap = Array(volume.x * volume.y * volume.z);\n\n  // eslint-disable-next-line prefer-destructuring\n  for (let z = min.z, i = 0; z < max.z; z += 1) {\n    // eslint-disable-next-line prefer-destructuring\n    for (let y = min.y; y < max.y; y += 1) {\n      // eslint-disable-next-line prefer-destructuring\n      for (let x = min.x; x < max.x; x += 1, i += 1) {\n        occlusionMap[i] = String.fromCharCode(hasOcclusion(x, y, z) ? 0xFF : 0);\n      }\n    }\n  }\n\n  return {\n    data: btoa(occlusionMap.join('')),\n    origin: {\n      x: min.x + offset.x,\n      y: min.y + offset.y,\n      z: min.z + offset.z,\n    },\n    size: volume,\n  };\n};\n\nconst computePhysics = ({ includeGhost = true, offset = { x: 0, y: 0, z: 0 } }) => {\n  const hasMass = (x, y, z) => {\n    if (y < 0 || y >= maxHeight) {\n      return false;\n    }\n    const cx = Math.floor(x / size);\n    const cz = Math.floor(z / size);\n    const key = `${cx}:${cz}`;\n    const chunk = meshedChunks.get(key);\n    if (!chunk) {\n      return false;\n    }\n    x -= size * chunk.x;\n    z -= size * chunk.z;\n    const type = chunk.voxels[getIndex(x, y, z)];\n    return type !== 0 && (includeGhost || !types[type].isGhost) && types[type].model !== 'cross';\n  };\n\n  const { min, max } = [...meshedChunks.values()].reduce(({ min, max }, { x, z }) => ({\n    min: { x: Math.min(min.x, x * size), z: Math.min(min.z, z * size) },\n    max: { x: Math.max(max.x, (x + 1) * size), z: Math.max(max.z, (z + 1) * size) },\n  }), { min: { x: Infinity, z: Infinity }, max: { x: -Infinity, z: -Infinity } });\n\n  const boxes = [];\n  const map = new Map();\n\n  // eslint-disable-next-line prefer-destructuring\n  for (let x = min.x; x < max.x; x += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      // eslint-disable-next-line prefer-destructuring\n      for (let z = min.z; z < max.z; z += 1) {\n        if (hasMass(x, y, z) && !map.has(`${x}:${y}:${z}`)) {\n          const box = {\n            position: { x, y, z },\n            size: { x: 0, y: 0, z: 0 },\n          };\n          boxes.push(box);\n\n          for (let i = x + 1; i <= max.x; i += 1) {\n            if (!hasMass(i, y, z) || map.has(`${i}:${y}:${z}`)) {\n              box.size.x = i - x;\n              break;\n            }\n          }\n\n          box.size.y = maxHeight - y;\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y + 1; j <= y + box.size.y; j += 1) {\n              if (!hasMass(i, j, z) || map.has(`${i}:${j}:${z}`)) {\n                box.size.y = j - y;\n              }\n            }\n          }\n\n          box.size.z = max.z - z;\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y; j < y + box.size.y; j += 1) {\n              for (let k = z + 1; k <= z + box.size.z; k += 1) {\n                if (!hasMass(i, j, k) || map.has(`${i}:${j}:${k}`)) {\n                  box.size.z = k - z;\n                }\n              }\n            }\n          }\n\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y; j < y + box.size.y; j += 1) {\n              for (let k = z; k < z + box.size.z; k += 1) {\n                map.set(`${i}:${j}:${k}`, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return boxes.map(({ position, size }) => [\n    [position.x + offset.x, position.y + offset.y, position.z + offset.z],\n    [size.x, size.y, size.z],\n  ]);\n};\n\ncontext.addEventListener('message', ({ data: message }) => {\n  switch (message.type) {\n    case 'types': {\n      const previousTypes = types;\n      const textures = { alpha: 0, blending: 0, opaque: 0 };\n      types = [\n        {\n          name: 'Air',\n          isTranslucent: true,\n        },\n        ...message.types\n          .map((type) => {\n            let material = 'opaque';\n            if (type.hasAlpha) {\n              material = 'alpha';\n            } else if (type.hasBlending) {\n              material = 'blending';\n            }\n            const isCross = type.model === 'cross';\n            const index = textures[material];\n            if (!type.isGhost) {\n              textures[material] += isCross ? 1 : 3;\n            }\n            return {\n              ...type,\n              hasAO: !isCross,\n              isCulled: !isCross,\n              isTranslucent: isCross || type.hasAlpha || type.hasBlending,\n              textures: isCross ? [index] : [\n                index,\n                index + 2,\n                index + 1,\n                index + 1,\n                index + 1,\n                index + 1,\n              ],\n            };\n          })\n          .map((type) => ({\n            ...type,\n            textures: type.textures.map((index) => {\n              let material = 'opaque';\n              if (type.hasAlpha) {\n                material = 'alpha';\n              } else if (type.hasBlending) {\n                material = 'blending';\n              }\n              const slotSize = 1 / Math.max(textures[material], 9);\n              const slotPixel = slotSize / (textureWidth + 2);\n              const from = (index * slotSize) + slotPixel;\n              return {\n                from,\n                to: from + (slotPixel * textureWidth),\n              };\n            }),\n          })),\n        {\n          name: 'Bedrock',\n          hasAO: true,\n          isCulled: true,\n          isTranslucent: false,\n        },\n      ];\n      edges.bottom.type = types.length - 1;\n      if (previousTypes) {\n        let repropagate = false;\n        let remap = false;\n        if (types.length < previousTypes.length) {\n          repropagate = true;\n          remap = previousTypes.map(({ key }) => {\n            if (!key) {\n              return 0;\n            }\n            const index = types.findIndex(({ key: id }) => (id === key));\n            return ~index ? index : 0;\n          });\n        } else {\n          const len = previousTypes.length;\n          for (let i = 0; i < len; i += 1) {\n            const prev = previousTypes[i];\n            const current = types[i];\n            if (\n              prev.model !== current.model\n              || prev.hasAlpha !== current.hasAlpha\n              || prev.hasBlending !== current.hasBlending\n              || prev.isGhost !== current.isGhost\n              || prev.light !== current.light\n            ) {\n              repropagate = true;\n              break;\n            }\n          }\n        }\n        if (repropagate) {\n          [...chunks.values()].forEach(({ key }) => {\n            if (!meshedChunks.has(key)) {\n              chunks.delete(key);\n            }\n          });\n          [...meshedChunks.values()].forEach((chunk) => {\n            const { voxels } = chunk;\n            const { length } = voxels;\n            for (let i = 0; i < length; i += fields.count) {\n              if (remap) {\n                voxels[i] = remap[voxels[i]];\n              }\n              const { light } = types[voxels[i]];\n              voxels[i + fields.light1] = light === 1 ? maxLight : 0;\n              voxels[i + fields.light2] = light === 2 ? maxLight : 0;\n              voxels[i + fields.light3] = light === 3 ? maxLight : 0;\n              voxels[i + fields.sunlight] = 0;\n            }\n            chunk.hasPropagated = false;\n          });\n        }\n      }\n      remeshAll();\n      break;\n    }\n    case 'lighting':\n      lightChannels.light1 = message.channels.channel1;\n      lightChannels.light2 = message.channels.channel2;\n      lightChannels.light3 = message.channels.channel3;\n      lightChannels.sunlight = message.channels.sunlight;\n      remeshAll();\n      break;\n    case 'clone':\n      if (\n        message.from.y >= 0 && message.from.y < maxHeight\n        && message.to.y >= 0 && message.to.y < maxHeight\n      ) {\n        const chunk = clone(message.from, message.to);\n        [\n          chunk,\n          ...chunkNeighbors.map(({ x, z }) => ({\n            x: chunk.x + x,\n            z: chunk.z + z,\n          })),\n        ].forEach((chunk) => (\n          remeshDebounced(chunk.x, chunk.z)\n        ));\n      }\n      break;\n    case 'update':\n      if (message.update.y >= 0 && message.update.y < maxHeight) {\n        const chunk = update(message.update);\n        [\n          chunk,\n          ...chunkNeighbors.map(({ x, z }) => ({\n            x: chunk.x + x,\n            z: chunk.z + z,\n          })),\n        ].forEach((chunk) => (\n          remeshDebounced(chunk.x, chunk.z)\n        ));\n      }\n      break;\n    case 'pick': {\n      const { block } = message;\n      if (block.y >= 0 && block.y < maxHeight) {\n        const chunk = getChunk(\n          Math.floor(block.x / size),\n          Math.floor(block.z / size)\n        );\n        block.x -= size * chunk.x;\n        block.z -= size * chunk.z;\n        context.postMessage({\n          type: 'pick',\n          block: chunk.voxels[getIndex(block.x, block.y, block.z)],\n        });\n      }\n      break;\n    }\n    case 'load':\n      chunks.clear();\n      meshedChunks.clear();\n      types = undefined;\n      message.chunks.forEach(({ x, z, voxels: serialized }) => {\n        const key = `${x}:${z}`;\n        const deserialized = new Uint8ClampedArray(atob(serialized).split('').map((c) => c.charCodeAt(0)));\n        const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n        const heightmap = new Uint8ClampedArray(size ** 2);\n        for (let x = 0, i = 0, j = 0; x < size; x += 1) {\n          for (let y = 0; y < maxHeight; y += 1) {\n            for (let z = 0; z < size; z += 1, i += fields.count, j += 1) {\n              const type = deserialized[j];\n              voxels[i] = type;\n              if (type !== 0) {\n                const heightmapIndex = (x * size) + z;\n                if (heightmap[heightmapIndex] < y) {\n                  heightmap[heightmapIndex] = y;\n                }\n                const { light } = message.types[type - 1];\n                if (light) {\n                  voxels[i + fields[`light${light}`]] = maxLight;\n                }\n              }\n            }\n          }\n        }\n        const chunk = {\n          x,\n          z,\n          voxels,\n          heightmap,\n          hasPropagated: false,\n          key,\n        };\n        chunks.set(key, chunk);\n        meshedChunks.set(key, chunk);\n      });\n      break;\n    case 'save':\n      context.postMessage({\n        type: 'save',\n        chunks: [...meshedChunks.values()].map(({ x, z, voxels }) => {\n          const data = new Uint8ClampedArray(size * size * maxHeight);\n          const { length } = voxels;\n          for (let i = 0, j = 0; i < length; i += 1, j += fields.count) {\n            data[i] = voxels[j];\n          }\n          return {\n            x,\n            z,\n            voxels: btoa(String.fromCharCode.apply(null, data)),\n          };\n        }),\n      });\n      break;\n    case 'computeLightmap':\n      context.postMessage({\n        type: 'lightmap',\n        lightmap: computeLightmap(message),\n      });\n      break;\n    case 'computeOcclusion':\n      context.postMessage({\n        type: 'occlusion',\n        occlusion: computeOcclusion(message),\n      });\n      break;\n    case 'computePhysics':\n      context.postMessage({\n        type: 'physics',\n        boxes: computePhysics(message),\n      });\n      break;\n    case 'reset':\n      chunks.clear();\n      meshedChunks.clear();\n      break;\n    default:\n      break;\n  }\n});\n"],"names":["context","self","size","maxHeight","maxLight","fields","type","light1","light2","light3","sunlight","count","chunks","Map","lightChannels","r","g","b","types","allocate","cx","cz","x","z","voxels","Uint8ClampedArray","heightmap","hasPropagated","getChunk","key","chunk","get","set","getIndex","y","getVoxelChunk","origin","nx","Math","floor","nz","voxelNeighbors","floodLight","queue","isSunLight","length","shift","light","forEach","offset","ny","nl","voxel","isTranslucent","push","propagate","lightQueues","sunlightQueue","i","removeLight","fill","update","current","heightIndex","height","air","getLightColor","l1","l2","l3","s","ao","color","reduce","max","min","avg","getLighting","neighbors","map","n1","hasAO","n2","n3","n","c","edges","top","bottom","isVisible","neighbor","isGhost","isCulled","hasAlpha","hasBlending","chunkNeighbors","textureY","meshedChunks","mesh","has","getVoxelData","Array","v","subchunk","geometry","meshes","position","uv","index","pushFace","p1","p2","p3","p4","lighting","facing","texture","textures","uvs","from","to","vertices","unshift","pop","opaque","alpha","blending","ghost","vertex","box","south","north","west","east","e","w","t","cross","doubleSide","fromY","toY","model","Float32Array","Uint8Array","Uint16Array","remeshDebounced","debounce","remeshQueued","values","subchunks","postMessage","buffers","buffer","clear","clearTimeout","setTimeout","remeshAll","list","computeLightmap","getLight","Infinity","ceil","volume","lightmap","j","String","fromCharCode","channels","data","btoa","join","computeOcclusion","includeGhost","hasOcclusion","occlusionMap","computePhysics","hasMass","boxes","k","addEventListener","message","previousTypes","name","material","isCross","slotSize","slotPixel","repropagate","remap","findIndex","id","len","prev","delete","channel1","channel2","channel3","clone","block","undefined","serialized","deserialized","atob","split","charCodeAt","heightmapIndex","apply","occlusion"],"mappings":"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"}