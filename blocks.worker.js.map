{"version":3,"file":"blocks.worker.js","sources":["../src/workers/blocks.js"],"sourcesContent":["// eslint-disable-next-line no-restricted-globals\nconst context = self;\n\nconst size = 16;\nconst subchunks = 5;\nconst maxHeight = size * subchunks;\nconst maxLight = 15;\nconst fields = {\n  type: 0,\n  light: 1,\n  sunlight: 2,\n  count: 3,\n};\nconst textureWidth = 16;\nconst textureHeight = 16;\n\nconst chunks = new Map();\nlet sunlightIntensity = 1;\nlet types;\n\nconst allocate = (cx, cz) => {\n  const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n  const heightmap = new Uint8ClampedArray(size ** 2);\n  return {\n    x: cx,\n    z: cz,\n    voxels,\n    heightmap,\n    hasPropagated: false,\n  };\n};\n\nconst getChunk = (cx, cz) => {\n  const key = `${cx}:${cz}`;\n  let chunk = chunks.get(key);\n  if (!chunk) {\n    chunk = {\n      ...allocate(cx, cz),\n      key,\n    };\n    chunks.set(key, chunk);\n  }\n  return chunk;\n};\n\nconst getIndex = (x, y, z) => (\n  ((x * size * maxHeight) + (y * size) + z) * fields.count\n);\n\nconst getVoxelChunk = (origin) => (x, z) => {\n  let chunk = origin;\n  const nx = (x < 0 || x >= size) ? Math.floor(x / size) : 0;\n  const nz = (z < 0 || z >= size) ? Math.floor(z / size) : 0;\n  if (nx || nz) {\n    chunk = getChunk(origin.x + nx, origin.z + nz);\n    x -= size * nx;\n    z -= size * nz;\n  }\n  return { chunk, cx: x, cz: z };\n};\n\nconst voxelNeighbors = [\n  { x: 1, y: 0, z: 0 },\n  { x: -1, y: 0, z: 0 },\n  { x: 0, y: 0, z: 1 },\n  { x: 0, y: 0, z: -1 },\n  { x: 0, y: 1, z: 0 },\n  { x: 0, y: -1, z: 0 },\n];\nconst floodLight = (origin, queue, key = 'light') => {\n  const getChunk = getVoxelChunk(origin);\n  const isSunLight = key === 'sunlight';\n  const isTranslucent = (type) => types[type].isTranslucent;\n  while (queue.length) {\n    const { x, y, z } = queue.shift();\n    const { chunk, cx, cz } = getChunk(x, z);\n    const light = chunk.voxels[\n      getIndex(cx, y, cz) + fields[key]\n    ];\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const nl = light - ((isSunLight && offset.y === -1 && light === maxLight) ? 0 : 1);\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      if (\n        !isTranslucent(chunk.voxels[voxel])\n        || (\n          isSunLight\n          && offset.y !== -1\n          && light === maxLight\n          && ny > chunk.heightmap[(cx * size) + cz]\n        )\n        || chunk.voxels[voxel + fields[key]] >= nl\n      ) {\n        return;\n      }\n      chunk.voxels[voxel + fields[key]] = nl;\n      queue.push({ x: nx, y: ny, z: nz });\n    });\n  }\n};\n\nconst propagate = (chunk) => {\n  const lightQueue = [];\n  const sunlightQueue = [];\n  const top = maxHeight - 1;\n  for (let x = 0; x < size; x += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      for (let z = 0; z < size; z += 1) {\n        const i = getIndex(x, y, z);\n        const type = chunk.voxels[i];\n        if (y === top && types[type].isTranslucent) {\n          chunk.voxels[i + fields.sunlight] = maxLight;\n          sunlightQueue.push({ x, y: top, z });\n        } else if (types[type].isLight) {\n          chunk.voxels[i + fields.light] = maxLight;\n          lightQueue.push({ x, y, z });\n        }\n      }\n    }\n  }\n  floodLight(chunk, lightQueue, 'light');\n  floodLight(chunk, sunlightQueue, 'sunlight');\n  chunk.hasPropagated = true;\n};\n\nconst removeLight = (origin, x, y, z, key = 'light') => {\n  const getChunk = getVoxelChunk(origin);\n  const { chunk, cx, cz } = getChunk(x, z);\n  const voxel = getIndex(cx, y, cz);\n  const fill = [];\n  const queue = [];\n  queue.push({\n    x,\n    y,\n    z,\n    light: chunk.voxels[voxel + fields[key]],\n  });\n  chunk.voxels[voxel + fields[key]] = 0;\n  const isSunLight = key === 'sunlight';\n  while (queue.length) {\n    const {\n      x,\n      y,\n      z,\n      light,\n    } = queue.shift();\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      const nl = chunk.voxels[voxel + fields[key]];\n      if (nl === 0) {\n        return;\n      }\n      if (\n        nl < light\n        || (\n          isSunLight\n          && offset.y === -1\n          && light === maxLight\n          && nl === maxLight\n        )\n      ) {\n        queue.push({\n          x: nx,\n          y: ny,\n          z: nz,\n          light: nl,\n        });\n        chunk.voxels[voxel + fields[key]] = 0;\n      } else if (nl >= light) {\n        fill.push({\n          x: nx,\n          y: ny,\n          z: nz,\n        });\n      }\n    });\n  }\n  floodLight(origin, fill, key);\n};\n\nconst update = ({\n  x,\n  y,\n  z,\n  type,\n}) => {\n  const chunk = getChunk(\n    Math.floor(x / size),\n    Math.floor(z / size)\n  );\n  x -= size * chunk.x;\n  z -= size * chunk.z;\n  const {\n    heightmap,\n    voxels,\n    hasPropagated,\n  } = chunk;\n  const voxel = getIndex(x, y, z);\n  const current = voxels[voxel];\n  voxels[voxel] = type;\n  const heightIndex = (x * size) + z;\n  const height = heightmap[heightIndex];\n  if (type === types.air) {\n    if (y === height) {\n      for (let i = y - 1; i >= 0; i -= 1) {\n        if (i === 0 || voxels[getIndex(x, i, z)] !== 0) {\n          heightmap[heightIndex] = i;\n          break;\n        }\n      }\n    }\n  } else if (height < y) {\n    heightmap[heightIndex] = y;\n  }\n  if (hasPropagated) {\n    if (types[current].isLight) {\n      removeLight(chunk, x, y, z);\n    } else if (types[current].isTranslucent && !types[type].isTranslucent) {\n      ['light', 'sunlight'].forEach((key) => {\n        if (voxels[voxel + fields[key]] !== 0) {\n          removeLight(chunk, x, y, z, key);\n        }\n      });\n    }\n    if (types[type].isLight) {\n      voxels[voxel + fields.light] = maxLight;\n      floodLight(chunk, [{ x, y, z }]);\n    } else if (types[type].isTranslucent && !types[current].isTranslucent) {\n      const getChunk = getVoxelChunk(chunk);\n      ['light', 'sunlight'].forEach((key) => {\n        const queue = [];\n        if (key === 'sunlight' && y === maxHeight - 1) {\n          voxels[voxel + fields[key]] = maxLight;\n          queue.push({ x, y, z });\n        } else {\n          voxelNeighbors.forEach((offset) => {\n            const ny = y + offset.y;\n            if (ny < 0 || ny >= maxHeight) {\n              return;\n            }\n            const nx = x + offset.x;\n            const nz = z + offset.z;\n            const { chunk, cx, cz } = getChunk(nx, nz);\n            const voxel = getIndex(cx, ny, cz);\n            const { isLight, isTranslucent } = types[chunk.voxels[voxel]];\n            if (\n              chunk.voxels[voxel + fields[key]] !== 0\n              && (isTranslucent || (isLight && key === 'light'))\n            ) {\n              queue.push({ x: nx, y: ny, z: nz });\n            }\n          });\n        }\n        floodLight(chunk, queue, key);\n      });\n    }\n  }\n  return chunk;\n};\n\nconst getLighting = ({ light, sunlight }, neighbors) => neighbors.map((neighbors) => {\n  let n1 = types[neighbors[0].type].hasAO;\n  let n2 = types[neighbors[1].type].hasAO;\n  let n3 = (n1 && n2) || types[neighbors[2].type].hasAO;\n  const ao = [n1, n2, n3].reduce((ao, n) => (\n    ao - (n ? 0.2 : 0)\n  ), 1);\n  let c = 1;\n  let l = light;\n  let s = sunlight;\n  n1 = types[neighbors[0].type].isTranslucent;\n  n2 = types[neighbors[1].type].isTranslucent;\n  n3 = (n1 || n2) && types[neighbors[2].type].isTranslucent;\n  [n1, n2, n3].forEach((n, i) => {\n    if (n) {\n      l += neighbors[i].light;\n      s += neighbors[i].sunlight;\n      c += 1;\n    }\n  });\n  return (\n    Math.max(\n      Math.max(l, s * sunlightIntensity) / c / maxLight,\n      0.05\n    ) * ao\n  );\n});\n\nconst edge = { type: 0, light: 0, sunlight: maxLight };\nconst getVoxelData = (origin) => {\n  const getChunk = getVoxelChunk(origin);\n  return (x, y, z) => {\n    if (y < 0 || y >= maxHeight) {\n      return edge;\n    }\n    const { chunk, cx, cz } = getChunk(x, z);\n    const i = getIndex(cx, y, cz);\n    return {\n      type: chunk.voxels[i],\n      light: chunk.voxels[i + fields.light],\n      sunlight: chunk.voxels[i + fields.sunlight],\n    };\n  };\n};\n\nconst isVisible = (type, neighbor) => (\n  !types[type].isCulled\n  || !types[neighbor].isCulled\n  || (\n    types[neighbor].isTransparent\n    && (\n      !types[type].isTransparent\n      || type !== neighbor\n    )\n  )\n);\n\nconst chunkNeighbors = [\n  { x: -1, z: -1 },\n  { x: 0, z: -1 },\n  { x: 1, z: -1 },\n  { x: -1, z: 0 },\n  { x: 1, z: 0 },\n  { x: -1, z: 1 },\n  { x: 0, z: 1 },\n  { x: 1, z: 1 },\n];\nconst textureY = {\n  from: 1 / (textureHeight + 2),\n  to: (textureHeight + 1) / (textureHeight + 2),\n};\nconst meshedChunks = new Map();\nconst mesh = (cx, cz) => {\n  const chunk = getChunk(cx, cz);\n  if (!meshedChunks.has(chunk.key)) {\n    meshedChunks.set(chunk.key, chunk);\n  }\n  if (!chunk.hasPropagated) {\n    propagate(chunk);\n  }\n  chunkNeighbors.forEach(({ x, z }) => {\n    const neighbor = getChunk(chunk.x + x, chunk.z + z);\n    if (!neighbor.hasPropagated) {\n      propagate(neighbor);\n    }\n  });\n  const get = getVoxelData(chunk);\n  return [...Array(subchunks)].map((v, subchunk) => {\n    const geometry = {\n      opaque: {\n        color: [],\n        position: [],\n        uv: [],\n        index: [],\n        offset: 0,\n      },\n      transparent: {\n        color: [],\n        position: [],\n        uv: [],\n        index: [],\n        offset: 0,\n      },\n    };\n    const pushFace = (\n      p1,\n      p2,\n      p3,\n      p4,\n      type,\n      lighting,\n      facing\n    ) => {\n      const texture = types[type].textures[facing % 6];\n      const uvs = [\n        [texture.from, facing + textureY.to],\n        [texture.to, facing + textureY.to],\n        [texture.to, facing + textureY.from],\n        [texture.from, facing + textureY.from],\n      ];\n      const vertices = [p1, p2, p3, p4];\n      if (lighting[0] + lighting[2] < lighting[1] + lighting[3]) {\n        lighting.unshift(lighting.pop());\n        uvs.unshift(uvs.pop());\n        vertices.unshift(vertices.pop());\n      }\n      const mesh = types[type].isTransparent ? geometry.transparent : geometry.opaque;\n      lighting.forEach((light) => mesh.color.push(light, light, light));\n      uvs.forEach((uv) => mesh.uv.push(...uv));\n      vertices.forEach((vertex) => mesh.position.push(...vertex));\n      [0, 1, 2, 2, 3, 0].forEach((i) => mesh.index.push(mesh.offset + i));\n      mesh.offset += 4;\n    };\n    const box = (x, y, z, type) => {\n      const top = get(x, y + 1, z);\n      const bottom = get(x, y - 1, z);\n      const south = get(x, y, z + 1);\n      const north = get(x, y, z - 1);\n      const west = get(x - 1, y, z);\n      const east = get(x + 1, y, z);\n      if (isVisible(type, top.type)) {\n        const n = get(x, y + 1, z - 1);\n        const e = get(x + 1, y + 1, z);\n        const w = get(x - 1, y + 1, z);\n        const s = get(x, y + 1, z + 1);\n        pushFace(\n          [x, y + 1, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x + 1, y + 1, z],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            top,\n            [\n              [w, s, get(x - 1, y + 1, z + 1)],\n              [e, s, get(x + 1, y + 1, z + 1)],\n              [e, n, get(x + 1, y + 1, z - 1)],\n              [w, n, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          0\n        );\n      }\n      if (isVisible(type, bottom.type)) {\n        const n = get(x, y - 1, z - 1);\n        const e = get(x + 1, y - 1, z);\n        const w = get(x - 1, y - 1, z);\n        const s = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z],\n          [x + 1, y, z],\n          [x + 1, y, z + 1],\n          [x, y, z + 1],\n          type,\n          getLighting(\n            bottom,\n            [\n              [w, n, get(x - 1, y - 1, z - 1)],\n              [e, n, get(x + 1, y - 1, z - 1)],\n              [e, s, get(x + 1, y - 1, z + 1)],\n              [w, s, get(x - 1, y - 1, z + 1)],\n            ]\n          ),\n          1\n        );\n      }\n      if (isVisible(type, south.type)) {\n        const e = get(x + 1, y, z + 1);\n        const w = get(x - 1, y, z + 1);\n        const t = get(x, y + 1, z + 1);\n        const b = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z + 1],\n          [x + 1, y, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x, y + 1, z + 1],\n          type,\n          getLighting(\n            south,\n            [\n              [w, b, get(x - 1, y - 1, z + 1)],\n              [e, b, get(x + 1, y - 1, z + 1)],\n              [e, t, get(x + 1, y + 1, z + 1)],\n              [w, t, get(x - 1, y + 1, z + 1)],\n            ]\n          ),\n          2\n        );\n      }\n      if (isVisible(type, north.type)) {\n        const e = get(x + 1, y, z - 1);\n        const w = get(x - 1, y, z - 1);\n        const t = get(x, y + 1, z - 1);\n        const b = get(x, y - 1, z - 1);\n        pushFace(\n          [x + 1, y, z],\n          [x, y, z],\n          [x, y + 1, z],\n          [x + 1, y + 1, z],\n          type,\n          getLighting(\n            north,\n            [\n              [e, b, get(x + 1, y - 1, z - 1)],\n              [w, b, get(x - 1, y - 1, z - 1)],\n              [w, t, get(x - 1, y + 1, z - 1)],\n              [e, t, get(x + 1, y + 1, z - 1)],\n            ]\n          ),\n          3\n        );\n      }\n      if (isVisible(type, west.type)) {\n        const n = get(x - 1, y, z - 1);\n        const s = get(x - 1, y, z + 1);\n        const t = get(x - 1, y + 1, z);\n        const b = get(x - 1, y - 1, z);\n        pushFace(\n          [x, y, z],\n          [x, y, z + 1],\n          [x, y + 1, z + 1],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            west,\n            [\n              [n, b, get(x - 1, y - 1, z - 1)],\n              [s, b, get(x - 1, y - 1, z + 1)],\n              [s, t, get(x - 1, y + 1, z + 1)],\n              [n, t, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          4\n        );\n      }\n      if (isVisible(type, east.type)) {\n        const n = get(x + 1, y, z - 1);\n        const s = get(x + 1, y, z + 1);\n        const t = get(x + 1, y + 1, z);\n        const b = get(x + 1, y - 1, z);\n        pushFace(\n          [x + 1, y, z + 1],\n          [x + 1, y, z],\n          [x + 1, y + 1, z],\n          [x + 1, y + 1, z + 1],\n          type,\n          getLighting(\n            east,\n            [\n              [s, b, get(x + 1, y - 1, z + 1)],\n              [n, b, get(x + 1, y - 1, z - 1)],\n              [n, t, get(x + 1, y + 1, z - 1)],\n              [s, t, get(x + 1, y + 1, z + 1)],\n            ]\n          ),\n          5\n        );\n      }\n    };\n    const cross = (x, y, z, { type, light, sunlight }) => {\n      const lighting = (() => {\n        const lighting = Math.max(\n          Math.max(light, sunlight * sunlightIntensity) / maxLight,\n          0.05\n        );\n        return [...Array(4)].map(() => lighting);\n      })();\n      pushFace(\n        [x, y, z],\n        [x + 1, y, z + 1],\n        [x + 1, y + 1, z + 1],\n        [x, y + 1, z],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x, y, z + 1],\n        [x + 1, y, z],\n        [x + 1, y + 1, z],\n        [x, y + 1, z + 1],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x + 1, y, z + 1],\n        [x, y, z],\n        [x, y + 1, z],\n        [x + 1, y + 1, z + 1],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x + 1, y, z],\n        [x, y, z + 1],\n        [x, y + 1, z + 1],\n        [x + 1, y + 1, z],\n        type,\n        lighting,\n        6\n      );\n    };\n    const fromY = subchunk * size;\n    const toY = (subchunk + 1) * size;\n    for (let x = 0; x < size; x += 1) {\n      for (let y = fromY; y < toY; y += 1) {\n        for (let z = 0; z < size; z += 1) {\n          const voxel = get(x, y, z);\n          if (voxel.type !== 0) {\n            switch (types[voxel.type].model) {\n              case 'cross':\n                cross(x, y, z, voxel);\n                break;\n              default:\n                box(x, y, z, voxel.type);\n                break;\n            }\n          }\n        }\n      }\n    }\n    return ['opaque', 'transparent'].reduce((meshes, key) => {\n      const {\n        color,\n        position,\n        uv,\n        index,\n      } = geometry[key];\n      meshes[key] = {\n        color: new Float32Array(color),\n        position: new Uint8Array(position),\n        uv: new Float32Array(uv),\n        index: new Uint16Array(index),\n      };\n      return meshes;\n    }, {});\n  });\n};\n\nconst remesh = (x, z) => {\n  const subchunks = mesh(x, z);\n  context.postMessage({\n    type: 'chunk',\n    position: { x, z },\n    subchunks,\n  }, subchunks.reduce((buffers, meshes) => {\n    ['opaque', 'transparent'].forEach((mesh) => {\n      mesh = meshes[mesh];\n      buffers.push(\n        mesh.color.buffer,\n        mesh.position.buffer,\n        mesh.uv.buffer,\n        mesh.index.buffer\n      );\n    });\n    return buffers;\n  }, []));\n};\n\nconst remeshDebounced = (() => {\n  let debounce;\n  const queue = new Map();\n  const remeshQueued = () => {\n    [...queue.values()].forEach((chunk) => (\n      remesh(chunk.x, chunk.z)\n    ));\n    queue.clear();\n  };\n  return (x, z) => {\n    queue.set(`${x}:${z}`, { x, z });\n    if (debounce) {\n      clearTimeout(debounce);\n    }\n    debounce = setTimeout(remeshQueued, 0);\n  };\n})();\n\nconst remeshAll = (() => {\n  let debounce;\n  const remeshAll = () => {\n    const list = [...meshedChunks.values()];\n    if (!list.length) {\n      remesh(0, 0);\n      return;\n    }\n    list.forEach((chunk) => (\n      remesh(chunk.x, chunk.z)\n    ));\n  };\n  return () => {\n    if (debounce) {\n      clearTimeout(debounce);\n    }\n    debounce = setTimeout(remeshAll, 0);\n  };\n})();\n\ncontext.addEventListener('message', ({ data: message }) => {\n  switch (message.type) {\n    case 'types': {\n      const previousTypes = types;\n      const textures = { opaque: 0, transparent: 0 };\n      types = [\n        {\n          name: 'Air',\n          isLight: false,\n          isTranslucent: true,\n        },\n        ...message.types\n          .map((type) => {\n            const material = type.isTransparent ? 'transparent' : 'opaque';\n            const index = textures[material];\n            textures[material] += 3;\n            return {\n              ...type,\n              hasAO: type.model !== 'cross',\n              isCulled: type.model !== 'cross',\n              isTranslucent: type.isTransparent || type.model === 'cross',\n              textures: [\n                index + 2,\n                index,\n                index + 1,\n                index + 1,\n                index + 1,\n                index + 1,\n              ],\n            };\n          })\n          .map((type) => ({\n            ...type,\n            textures: type.textures.map((index) => {\n              const slotSize = 1 / textures[type.isTransparent ? 'transparent' : 'opaque'];\n              const slotPixel = slotSize / (textureWidth + 2);\n              const from = (index * slotSize) + slotPixel;\n              return {\n                from,\n                to: from + (slotPixel * textureWidth),\n              };\n            }),\n          })),\n      ];\n      if (previousTypes) {\n        let repropagate = false;\n        let remap = false;\n        if (types.length < previousTypes.length) {\n          repropagate = true;\n          remap = previousTypes.map(({ key }) => {\n            if (!key) {\n              return 0;\n            }\n            const index = types.findIndex(({ key: id }) => (id === key));\n            return ~index ? index : 0;\n          });\n        } else {\n          const len = previousTypes.length;\n          for (let i = 0; i < len; i += 1) {\n            const prev = previousTypes[i];\n            const current = types[i];\n            if (\n              prev.model !== current.model\n              || prev.isLight !== current.isLight\n              || prev.isTransparent !== current.isTransparent\n            ) {\n              repropagate = true;\n              break;\n            }\n          }\n        }\n        if (repropagate) {\n          [...chunks.values()].forEach(({ key }) => {\n            if (!meshedChunks.has(key)) {\n              chunks.delete(key);\n            }\n          });\n          [...meshedChunks.values()].forEach((chunk) => {\n            const { voxels } = chunk;\n            const { length } = voxels;\n            for (let i = 0; i < length; i += fields.count) {\n              if (remap) {\n                voxels[i] = remap[voxels[i]];\n              }\n              voxels[i + fields.light] = types[voxels[i]].isLight ? maxLight : 0;\n              voxels[i + fields.sunlight] = 0;\n            }\n            chunk.hasPropagated = false;\n          });\n        }\n      }\n      remeshAll();\n      break;\n    }\n    case 'sunlight':\n      sunlightIntensity = message.intensity;\n      remeshAll();\n      break;\n    case 'update':\n      if (message.update.y > 0 && message.update.y < maxHeight) {\n        const chunk = update(message.update);\n        [\n          chunk,\n          ...chunkNeighbors.map(({ x, z }) => ({\n            x: chunk.x + x,\n            z: chunk.z + z,\n          })),\n        ].forEach((chunk) => (\n          remeshDebounced(chunk.x, chunk.z)\n        ));\n      }\n      break;\n    case 'pick': {\n      const { block } = message;\n      if (block.y > 0 && block.y < maxHeight) {\n        const chunk = getChunk(\n          Math.floor(block.x / size),\n          Math.floor(block.z / size)\n        );\n        block.x -= size * chunk.x;\n        block.z -= size * chunk.z;\n        context.postMessage({\n          type: 'pick',\n          block: chunk.voxels[getIndex(block.x, block.y, block.z)],\n        });\n      }\n      break;\n    }\n    case 'load':\n      chunks.clear();\n      meshedChunks.clear();\n      types = undefined;\n      message.chunks.forEach(({ x, z, voxels: serialized }) => {\n        const key = `${x}:${z}`;\n        const deserialized = new Uint8ClampedArray(atob(serialized).split('').map((c) => c.charCodeAt(0)));\n        const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n        const heightmap = new Uint8ClampedArray(size ** 2);\n        for (let x = 0, i = 0, j = 0; x < size; x += 1) {\n          for (let y = 0; y < maxHeight; y += 1) {\n            for (let z = 0; z < size; z += 1, i += fields.count, j += 1) {\n              const type = deserialized[j];\n              voxels[i] = type;\n              if (type !== 0) {\n                const heightmapIndex = (x * size) + z;\n                if (heightmap[heightmapIndex] < y) {\n                  heightmap[heightmapIndex] = y;\n                }\n                if (message.types[type - 1].isLight) {\n                  voxels[i + fields.light] = maxLight;\n                }\n              }\n            }\n          }\n        }\n        const chunk = {\n          x,\n          z,\n          voxels,\n          heightmap,\n          hasPropagated: false,\n          key,\n        };\n        chunks.set(key, chunk);\n        meshedChunks.set(key, chunk);\n      });\n      break;\n    case 'save':\n      context.postMessage({\n        type: 'save',\n        chunks: [...meshedChunks.values()].map(({ x, z, voxels }) => {\n          const data = new Uint8ClampedArray(size * size * maxHeight);\n          const { length } = voxels;\n          for (let i = 0, j = 0; i < length; i += 1, j += fields.count) {\n            data[i] = voxels[j];\n          }\n          return {\n            x,\n            z,\n            voxels: btoa(String.fromCharCode.apply(null, data)),\n          };\n        }),\n      });\n      break;\n    case 'reset':\n      chunks.clear();\n      meshedChunks.clear();\n      break;\n    default:\n      break;\n  }\n});\n"],"names":["context","self","size","maxHeight","maxLight","fields","type","light","sunlight","count","chunks","Map","types","sunlightIntensity","allocate","cx","cz","x","z","voxels","Uint8ClampedArray","heightmap","hasPropagated","getChunk","key","chunk","get","set","getIndex","y","getVoxelChunk","origin","nx","Math","floor","nz","voxelNeighbors","floodLight","queue","isSunLight","length","shift","forEach","offset","ny","nl","voxel","isTranslucent","push","propagate","lightQueue","sunlightQueue","i","isLight","removeLight","fill","getLighting","neighbors","map","n1","hasAO","n2","n3","ao","reduce","n","c","l","s","max","edge","isVisible","neighbor","isCulled","isTransparent","chunkNeighbors","textureY","meshedChunks","mesh","has","getVoxelData","Array","v","subchunk","geometry","opaque","color","position","uv","index","transparent","pushFace","p1","p2","p3","p4","lighting","facing","texture","textures","uvs","from","to","vertices","unshift","pop","vertex","box","top","bottom","south","north","west","east","e","w","t","b","cross","fromY","toY","model","meshes","Float32Array","Uint8Array","Uint16Array","remesh","subchunks","postMessage","buffers","buffer","remeshDebounced","debounce","remeshQueued","values","clear","clearTimeout","setTimeout","remeshAll","list","addEventListener","data","message","previousTypes","name","material","slotSize","slotPixel","repropagate","remap","findIndex","id","len","prev","current","delete","intensity","update","heightIndex","height","air","block","undefined","serialized","deserialized","atob","split","charCodeAt","j","heightmapIndex","btoa","String","fromCharCode","apply"],"mappings":"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"}