{"version":3,"file":"blocks.worker.js","sources":["../src/workers/blocks.js"],"sourcesContent":["// eslint-disable-next-line no-restricted-globals\nconst context = self;\n\nconst size = 16;\nconst subchunks = 5;\nconst maxHeight = size * subchunks;\nconst maxLight = 15;\nconst fields = {\n  type: 0,\n  light: 1,\n  sunlight: 2,\n  count: 3,\n};\nconst textureWidth = 16;\nconst textureHeight = 16;\n\nconst chunks = new Map();\nlet sunlightIntensity = 1;\nlet types;\n\nconst allocate = (cx, cz) => {\n  const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n  const heightmap = new Uint8ClampedArray(size ** 2);\n  return {\n    x: cx,\n    z: cz,\n    voxels,\n    heightmap,\n    hasPropagated: false,\n  };\n};\n\nconst getChunk = (cx, cz) => {\n  const key = `${cx}:${cz}`;\n  let chunk = chunks.get(key);\n  if (!chunk) {\n    chunk = {\n      ...allocate(cx, cz),\n      key,\n    };\n    chunks.set(key, chunk);\n  }\n  return chunk;\n};\n\nconst getIndex = (x, y, z) => (\n  ((x * size * maxHeight) + (y * size) + z) * fields.count\n);\n\nconst getVoxelChunk = (origin) => (x, z) => {\n  let chunk = origin;\n  const nx = (x < 0 || x >= size) ? Math.floor(x / size) : 0;\n  const nz = (z < 0 || z >= size) ? Math.floor(z / size) : 0;\n  if (nx || nz) {\n    chunk = getChunk(origin.x + nx, origin.z + nz);\n    x -= size * nx;\n    z -= size * nz;\n  }\n  return { chunk, cx: x, cz: z };\n};\n\nconst voxelNeighbors = [\n  { x: 1, y: 0, z: 0 },\n  { x: -1, y: 0, z: 0 },\n  { x: 0, y: 0, z: 1 },\n  { x: 0, y: 0, z: -1 },\n  { x: 0, y: 1, z: 0 },\n  { x: 0, y: -1, z: 0 },\n];\nconst floodLight = (origin, queue, key = 'light') => {\n  const getChunk = getVoxelChunk(origin);\n  const isSunLight = key === 'sunlight';\n  const isTranslucent = (type) => types[type].isTranslucent;\n  while (queue.length) {\n    const { x, y, z } = queue.shift();\n    const { chunk, cx, cz } = getChunk(x, z);\n    const light = chunk.voxels[\n      getIndex(cx, y, cz) + fields[key]\n    ];\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const nl = light - ((isSunLight && offset.y === -1 && light === maxLight) ? 0 : 1);\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      if (\n        !isTranslucent(chunk.voxels[voxel])\n        || (\n          isSunLight\n          && offset.y !== -1\n          && light === maxLight\n          && ny > chunk.heightmap[(cx * size) + cz]\n        )\n        || chunk.voxels[voxel + fields[key]] >= nl\n      ) {\n        return;\n      }\n      chunk.voxels[voxel + fields[key]] = nl;\n      queue.push({ x: nx, y: ny, z: nz });\n    });\n  }\n};\n\nconst propagate = (chunk) => {\n  const lightQueue = [];\n  const sunlightQueue = [];\n  const top = maxHeight - 1;\n  for (let x = 0; x < size; x += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      for (let z = 0; z < size; z += 1) {\n        const i = getIndex(x, y, z);\n        const type = chunk.voxels[i];\n        if (y === top && types[type].isTranslucent) {\n          chunk.voxels[i + fields.sunlight] = maxLight;\n          sunlightQueue.push({ x, y: top, z });\n        } else if (types[type].isLight) {\n          chunk.voxels[i + fields.light] = maxLight;\n          lightQueue.push({ x, y, z });\n        }\n      }\n    }\n  }\n  floodLight(chunk, lightQueue, 'light');\n  floodLight(chunk, sunlightQueue, 'sunlight');\n  chunk.hasPropagated = true;\n};\n\nconst removeLight = (origin, x, y, z, key = 'light') => {\n  const getChunk = getVoxelChunk(origin);\n  const { chunk, cx, cz } = getChunk(x, z);\n  const voxel = getIndex(cx, y, cz);\n  const fill = [];\n  const queue = [];\n  queue.push({\n    x,\n    y,\n    z,\n    light: chunk.voxels[voxel + fields[key]],\n  });\n  chunk.voxels[voxel + fields[key]] = 0;\n  const isSunLight = key === 'sunlight';\n  while (queue.length) {\n    const {\n      x,\n      y,\n      z,\n      light,\n    } = queue.shift();\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      const nl = chunk.voxels[voxel + fields[key]];\n      if (nl === 0) {\n        return;\n      }\n      if (\n        nl < light\n        || (\n          isSunLight\n          && offset.y === -1\n          && light === maxLight\n          && nl === maxLight\n        )\n      ) {\n        queue.push({\n          x: nx,\n          y: ny,\n          z: nz,\n          light: nl,\n        });\n        chunk.voxels[voxel + fields[key]] = 0;\n      } else if (nl >= light) {\n        fill.push({\n          x: nx,\n          y: ny,\n          z: nz,\n        });\n      }\n    });\n  }\n  floodLight(origin, fill, key);\n};\n\nconst update = ({\n  x,\n  y,\n  z,\n  type,\n}) => {\n  const chunk = getChunk(\n    Math.floor(x / size),\n    Math.floor(z / size)\n  );\n  x -= size * chunk.x;\n  z -= size * chunk.z;\n  const {\n    heightmap,\n    voxels,\n    hasPropagated,\n  } = chunk;\n  const voxel = getIndex(x, y, z);\n  const current = voxels[voxel];\n  voxels[voxel] = type;\n  const heightIndex = (x * size) + z;\n  const height = heightmap[heightIndex];\n  if (type === types.air) {\n    if (y === height) {\n      for (let i = y - 1; i >= 0; i -= 1) {\n        if (i === 0 || voxels[getIndex(x, i, z)] !== 0) {\n          heightmap[heightIndex] = i;\n          break;\n        }\n      }\n    }\n  } else if (height < y) {\n    heightmap[heightIndex] = y;\n  }\n  if (hasPropagated) {\n    if (types[current].isLight) {\n      removeLight(chunk, x, y, z);\n    } else if (types[current].isTranslucent && !types[type].isTranslucent) {\n      ['light', 'sunlight'].forEach((key) => {\n        if (voxels[voxel + fields[key]] !== 0) {\n          removeLight(chunk, x, y, z, key);\n        }\n      });\n    }\n    if (types[type].isLight) {\n      voxels[voxel + fields.light] = maxLight;\n      floodLight(chunk, [{ x, y, z }]);\n    } else if (types[type].isTranslucent && !types[current].isTranslucent) {\n      const getChunk = getVoxelChunk(chunk);\n      ['light', 'sunlight'].forEach((key) => {\n        const queue = [];\n        if (key === 'sunlight' && y === maxHeight - 1) {\n          voxels[voxel + fields[key]] = maxLight;\n          queue.push({ x, y, z });\n        } else {\n          voxelNeighbors.forEach((offset) => {\n            const ny = y + offset.y;\n            if (ny < 0 || ny >= maxHeight) {\n              return;\n            }\n            const nx = x + offset.x;\n            const nz = z + offset.z;\n            const { chunk, cx, cz } = getChunk(nx, nz);\n            const voxel = getIndex(cx, ny, cz);\n            const { isLight, isTranslucent } = types[chunk.voxels[voxel]];\n            if (\n              chunk.voxels[voxel + fields[key]] !== 0\n              && (isTranslucent || (isLight && key === 'light'))\n            ) {\n              queue.push({ x: nx, y: ny, z: nz });\n            }\n          });\n        }\n        floodLight(chunk, queue, key);\n      });\n    }\n  }\n  return chunk;\n};\n\nconst clone = ({ x, y, z }, to) => {\n  const chunk = getChunk(\n    Math.floor(x / size),\n    Math.floor(z / size)\n  );\n  x -= size * chunk.x;\n  z -= size * chunk.z;\n  return update({\n    ...to,\n    type: chunk.voxels[getIndex(x, y, z)],\n  });\n};\n\nconst getLighting = ({ light, sunlight }, neighbors) => neighbors.map((neighbors) => {\n  let n1 = types[neighbors[0].type].hasAO;\n  let n2 = types[neighbors[1].type].hasAO;\n  let n3 = (n1 && n2) || types[neighbors[2].type].hasAO;\n  const ao = [n1, n2, n3].reduce((ao, n) => (\n    ao - (n ? 0.2 : 0)\n  ), 1);\n  let c = 1;\n  let l = light;\n  let s = sunlight;\n  n1 = types[neighbors[0].type].isTranslucent;\n  n2 = types[neighbors[1].type].isTranslucent;\n  n3 = (n1 || n2) && types[neighbors[2].type].isTranslucent;\n  [n1, n2, n3].forEach((n, i) => {\n    if (n) {\n      l += neighbors[i].light;\n      s += neighbors[i].sunlight;\n      c += 1;\n    }\n  });\n  return (\n    Math.max(\n      Math.max(l, s * sunlightIntensity) / c / maxLight,\n      0.05\n    ) * ao\n  );\n});\n\nconst edge = { type: 0, light: 0, sunlight: maxLight };\nconst getVoxelData = (origin) => {\n  const getChunk = getVoxelChunk(origin);\n  return (x, y, z) => {\n    if (y < 0 || y >= maxHeight) {\n      return edge;\n    }\n    const { chunk, cx, cz } = getChunk(x, z);\n    const i = getIndex(cx, y, cz);\n    return {\n      type: chunk.voxels[i],\n      light: chunk.voxels[i + fields.light],\n      sunlight: chunk.voxels[i + fields.sunlight],\n    };\n  };\n};\n\nconst isVisible = (type, neighbor) => (\n  !types[type].isCulled\n  || !types[neighbor].isCulled\n  || (\n    types[neighbor].isTransparent\n    && (\n      !types[type].isTransparent\n      || type !== neighbor\n    )\n  )\n);\n\nconst chunkNeighbors = [\n  { x: -1, z: -1 },\n  { x: 0, z: -1 },\n  { x: 1, z: -1 },\n  { x: -1, z: 0 },\n  { x: 1, z: 0 },\n  { x: -1, z: 1 },\n  { x: 0, z: 1 },\n  { x: 1, z: 1 },\n];\nconst textureY = {\n  from: 1 / (textureHeight + 2),\n  to: (textureHeight + 1) / (textureHeight + 2),\n};\nconst meshedChunks = new Map();\nconst mesh = (cx, cz) => {\n  const chunk = getChunk(cx, cz);\n  if (!meshedChunks.has(chunk.key)) {\n    meshedChunks.set(chunk.key, chunk);\n  }\n  if (!chunk.hasPropagated) {\n    propagate(chunk);\n  }\n  chunkNeighbors.forEach(({ x, z }) => {\n    const neighbor = getChunk(chunk.x + x, chunk.z + z);\n    if (!neighbor.hasPropagated) {\n      propagate(neighbor);\n    }\n  });\n  const get = getVoxelData(chunk);\n  return [...Array(subchunks)].map((v, subchunk) => {\n    const geometry = {\n      opaque: {\n        color: [],\n        position: [],\n        uv: [],\n        index: [],\n        offset: 0,\n      },\n      transparent: {\n        color: [],\n        position: [],\n        uv: [],\n        index: [],\n        offset: 0,\n      },\n    };\n    const pushFace = (\n      p1,\n      p2,\n      p3,\n      p4,\n      type,\n      lighting,\n      facing\n    ) => {\n      const texture = types[type].textures[facing % 6];\n      const uvs = [\n        [texture.from, facing + textureY.to],\n        [texture.to, facing + textureY.to],\n        [texture.to, facing + textureY.from],\n        [texture.from, facing + textureY.from],\n      ];\n      const vertices = [p1, p2, p3, p4];\n      if (lighting[0] + lighting[2] < lighting[1] + lighting[3]) {\n        lighting.unshift(lighting.pop());\n        uvs.unshift(uvs.pop());\n        vertices.unshift(vertices.pop());\n      }\n      const mesh = types[type].isTransparent ? geometry.transparent : geometry.opaque;\n      lighting.forEach((light) => mesh.color.push(light, light, light));\n      uvs.forEach((uv) => mesh.uv.push(...uv));\n      vertices.forEach((vertex) => mesh.position.push(...vertex));\n      [0, 1, 2, 2, 3, 0].forEach((i) => mesh.index.push(mesh.offset + i));\n      mesh.offset += 4;\n    };\n    const box = (x, y, z, type) => {\n      const top = get(x, y + 1, z);\n      const bottom = get(x, y - 1, z);\n      const south = get(x, y, z + 1);\n      const north = get(x, y, z - 1);\n      const west = get(x - 1, y, z);\n      const east = get(x + 1, y, z);\n      if (isVisible(type, top.type)) {\n        const n = get(x, y + 1, z - 1);\n        const e = get(x + 1, y + 1, z);\n        const w = get(x - 1, y + 1, z);\n        const s = get(x, y + 1, z + 1);\n        pushFace(\n          [x, y + 1, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x + 1, y + 1, z],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            top,\n            [\n              [w, s, get(x - 1, y + 1, z + 1)],\n              [e, s, get(x + 1, y + 1, z + 1)],\n              [e, n, get(x + 1, y + 1, z - 1)],\n              [w, n, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          0\n        );\n      }\n      if (isVisible(type, bottom.type)) {\n        const n = get(x, y - 1, z - 1);\n        const e = get(x + 1, y - 1, z);\n        const w = get(x - 1, y - 1, z);\n        const s = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z],\n          [x + 1, y, z],\n          [x + 1, y, z + 1],\n          [x, y, z + 1],\n          type,\n          getLighting(\n            bottom,\n            [\n              [w, n, get(x - 1, y - 1, z - 1)],\n              [e, n, get(x + 1, y - 1, z - 1)],\n              [e, s, get(x + 1, y - 1, z + 1)],\n              [w, s, get(x - 1, y - 1, z + 1)],\n            ]\n          ),\n          1\n        );\n      }\n      if (isVisible(type, south.type)) {\n        const e = get(x + 1, y, z + 1);\n        const w = get(x - 1, y, z + 1);\n        const t = get(x, y + 1, z + 1);\n        const b = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z + 1],\n          [x + 1, y, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x, y + 1, z + 1],\n          type,\n          getLighting(\n            south,\n            [\n              [w, b, get(x - 1, y - 1, z + 1)],\n              [e, b, get(x + 1, y - 1, z + 1)],\n              [e, t, get(x + 1, y + 1, z + 1)],\n              [w, t, get(x - 1, y + 1, z + 1)],\n            ]\n          ),\n          2\n        );\n      }\n      if (isVisible(type, north.type)) {\n        const e = get(x + 1, y, z - 1);\n        const w = get(x - 1, y, z - 1);\n        const t = get(x, y + 1, z - 1);\n        const b = get(x, y - 1, z - 1);\n        pushFace(\n          [x + 1, y, z],\n          [x, y, z],\n          [x, y + 1, z],\n          [x + 1, y + 1, z],\n          type,\n          getLighting(\n            north,\n            [\n              [e, b, get(x + 1, y - 1, z - 1)],\n              [w, b, get(x - 1, y - 1, z - 1)],\n              [w, t, get(x - 1, y + 1, z - 1)],\n              [e, t, get(x + 1, y + 1, z - 1)],\n            ]\n          ),\n          3\n        );\n      }\n      if (isVisible(type, west.type)) {\n        const n = get(x - 1, y, z - 1);\n        const s = get(x - 1, y, z + 1);\n        const t = get(x - 1, y + 1, z);\n        const b = get(x - 1, y - 1, z);\n        pushFace(\n          [x, y, z],\n          [x, y, z + 1],\n          [x, y + 1, z + 1],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            west,\n            [\n              [n, b, get(x - 1, y - 1, z - 1)],\n              [s, b, get(x - 1, y - 1, z + 1)],\n              [s, t, get(x - 1, y + 1, z + 1)],\n              [n, t, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          4\n        );\n      }\n      if (isVisible(type, east.type)) {\n        const n = get(x + 1, y, z - 1);\n        const s = get(x + 1, y, z + 1);\n        const t = get(x + 1, y + 1, z);\n        const b = get(x + 1, y - 1, z);\n        pushFace(\n          [x + 1, y, z + 1],\n          [x + 1, y, z],\n          [x + 1, y + 1, z],\n          [x + 1, y + 1, z + 1],\n          type,\n          getLighting(\n            east,\n            [\n              [s, b, get(x + 1, y - 1, z + 1)],\n              [n, b, get(x + 1, y - 1, z - 1)],\n              [n, t, get(x + 1, y + 1, z - 1)],\n              [s, t, get(x + 1, y + 1, z + 1)],\n            ]\n          ),\n          5\n        );\n      }\n    };\n    const cross = (x, y, z, { type, light, sunlight }) => {\n      const lighting = (() => {\n        const lighting = Math.max(\n          Math.max(light, sunlight * sunlightIntensity) / maxLight,\n          0.05\n        );\n        return [...Array(4)].map(() => lighting);\n      })();\n      pushFace(\n        [x, y, z],\n        [x + 1, y, z + 1],\n        [x + 1, y + 1, z + 1],\n        [x, y + 1, z],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x, y, z + 1],\n        [x + 1, y, z],\n        [x + 1, y + 1, z],\n        [x, y + 1, z + 1],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x + 1, y, z + 1],\n        [x, y, z],\n        [x, y + 1, z],\n        [x + 1, y + 1, z + 1],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x + 1, y, z],\n        [x, y, z + 1],\n        [x, y + 1, z + 1],\n        [x + 1, y + 1, z],\n        type,\n        lighting,\n        6\n      );\n    };\n    const fromY = subchunk * size;\n    const toY = (subchunk + 1) * size;\n    for (let x = 0; x < size; x += 1) {\n      for (let y = fromY; y < toY; y += 1) {\n        for (let z = 0; z < size; z += 1) {\n          const voxel = get(x, y, z);\n          if (voxel.type !== 0) {\n            switch (types[voxel.type].model) {\n              case 'cross':\n                cross(x, y, z, voxel);\n                break;\n              default:\n                box(x, y, z, voxel.type);\n                break;\n            }\n          }\n        }\n      }\n    }\n    return ['opaque', 'transparent'].reduce((meshes, key) => {\n      const {\n        color,\n        position,\n        uv,\n        index,\n      } = geometry[key];\n      meshes[key] = {\n        color: new Float32Array(color),\n        position: new Uint8Array(position),\n        uv: new Float32Array(uv),\n        index: new Uint16Array(index),\n      };\n      return meshes;\n    }, {});\n  });\n};\n\nconst remesh = (x, z) => {\n  const subchunks = mesh(x, z);\n  context.postMessage({\n    type: 'chunk',\n    position: { x, z },\n    subchunks,\n  }, subchunks.reduce((buffers, meshes) => {\n    ['opaque', 'transparent'].forEach((mesh) => {\n      mesh = meshes[mesh];\n      buffers.push(\n        mesh.color.buffer,\n        mesh.position.buffer,\n        mesh.uv.buffer,\n        mesh.index.buffer\n      );\n    });\n    return buffers;\n  }, []));\n};\n\nconst remeshDebounced = (() => {\n  let debounce;\n  const queue = new Map();\n  const remeshQueued = () => {\n    [...queue.values()].forEach((chunk) => (\n      remesh(chunk.x, chunk.z)\n    ));\n    queue.clear();\n  };\n  return (x, z) => {\n    queue.set(`${x}:${z}`, { x, z });\n    if (debounce) {\n      clearTimeout(debounce);\n    }\n    debounce = setTimeout(remeshQueued, 0);\n  };\n})();\n\nconst remeshAll = (() => {\n  let debounce;\n  const remeshAll = () => {\n    const list = [...meshedChunks.values()];\n    if (!list.length) {\n      remesh(0, 0);\n      return;\n    }\n    list.forEach((chunk) => (\n      remesh(chunk.x, chunk.z)\n    ));\n  };\n  return () => {\n    if (debounce) {\n      clearTimeout(debounce);\n    }\n    debounce = setTimeout(remeshAll, 0);\n  };\n})();\n\nconst computePhysics = ({ offset = { x: -8, y: -1, z: -8 } }) => {\n  const hasMass = (x, y, z) => {\n    if (y < 0 || y >= maxHeight) {\n      return false;\n    }\n    const cx = Math.floor(x / size);\n    const cz = Math.floor(z / size);\n    const key = `${cx}:${cz}`;\n    const chunk = meshedChunks.get(key);\n    if (!chunk) {\n      return false;\n    }\n    x -= size * chunk.x;\n    z -= size * chunk.z;\n    const type = chunk.voxels[getIndex(x, y, z)];\n    return type !== 0 && types[type].model !== 'cross';\n  };\n\n  const { min, max } = [...meshedChunks.values()].reduce(({ min, max }, { x, z }) => ({\n    min: { x: Math.min(min.x, x * size), z: Math.min(min.z, z * size) },\n    max: { x: Math.max(max.x, (x + 1) * size), z: Math.max(max.z, (z + 1) * size) },\n  }), { min: { x: Infinity, z: Infinity }, max: { x: -Infinity, z: -Infinity } });\n\n  const boxes = [];\n  const map = new Map();\n\n  // eslint-disable-next-line prefer-destructuring\n  for (let x = min.x; x < max.x; x += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      // eslint-disable-next-line prefer-destructuring\n      for (let z = min.z; z < max.z; z += 1) {\n        if (hasMass(x, y, z) && !map.has(`${x}:${y}:${z}`)) {\n          const box = {\n            position: { x, y, z },\n            size: { x: 0, y: 0, z: 0 },\n          };\n          boxes.push(box);\n\n          for (let i = x + 1; i <= max.x; i += 1) {\n            if (!hasMass(i, y, z) || map.has(`${i}:${y}:${z}`)) {\n              box.size.x = i - x;\n              break;\n            }\n          }\n\n          box.size.y = maxHeight - y;\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y + 1; j <= y + box.size.y; j += 1) {\n              if (!hasMass(i, j, z) || map.has(`${i}:${j}:${z}`)) {\n                box.size.y = j - y;\n              }\n            }\n          }\n\n          box.size.z = max.z - z;\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y; j < y + box.size.y; j += 1) {\n              for (let k = z + 1; k <= z + box.size.z; k += 1) {\n                if (!hasMass(i, j, k) || map.has(`${i}:${j}:${k}`)) {\n                  box.size.z = k - z;\n                }\n              }\n            }\n          }\n\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y; j < y + box.size.y; j += 1) {\n              for (let k = z; k < z + box.size.z; k += 1) {\n                map.set(`${i}:${j}:${k}`, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return boxes.map(({ position, size }) => [\n    [position.x + offset.x, position.y + offset.y, position.z + offset.z],\n    [size.x, size.y, size.z],\n  ]);\n};\n\ncontext.addEventListener('message', ({ data: message }) => {\n  switch (message.type) {\n    case 'types': {\n      const previousTypes = types;\n      const textures = { opaque: 0, transparent: 0 };\n      types = [\n        {\n          name: 'Air',\n          isLight: false,\n          isTranslucent: true,\n        },\n        ...message.types\n          .map((type) => {\n            const material = type.isTransparent ? 'transparent' : 'opaque';\n            const index = textures[material];\n            textures[material] += 3;\n            return {\n              ...type,\n              hasAO: type.model !== 'cross',\n              isCulled: type.model !== 'cross',\n              isTranslucent: type.isTransparent || type.model === 'cross',\n              textures: [\n                index + 2,\n                index,\n                index + 1,\n                index + 1,\n                index + 1,\n                index + 1,\n              ],\n            };\n          })\n          .map((type) => ({\n            ...type,\n            textures: type.textures.map((index) => {\n              const slotSize = 1 / textures[type.isTransparent ? 'transparent' : 'opaque'];\n              const slotPixel = slotSize / (textureWidth + 2);\n              const from = (index * slotSize) + slotPixel;\n              return {\n                from,\n                to: from + (slotPixel * textureWidth),\n              };\n            }),\n          })),\n      ];\n      if (previousTypes) {\n        let repropagate = false;\n        let remap = false;\n        if (types.length < previousTypes.length) {\n          repropagate = true;\n          remap = previousTypes.map(({ key }) => {\n            if (!key) {\n              return 0;\n            }\n            const index = types.findIndex(({ key: id }) => (id === key));\n            return ~index ? index : 0;\n          });\n        } else {\n          const len = previousTypes.length;\n          for (let i = 0; i < len; i += 1) {\n            const prev = previousTypes[i];\n            const current = types[i];\n            if (\n              prev.model !== current.model\n              || prev.isLight !== current.isLight\n              || prev.isTransparent !== current.isTransparent\n            ) {\n              repropagate = true;\n              break;\n            }\n          }\n        }\n        if (repropagate) {\n          [...chunks.values()].forEach(({ key }) => {\n            if (!meshedChunks.has(key)) {\n              chunks.delete(key);\n            }\n          });\n          [...meshedChunks.values()].forEach((chunk) => {\n            const { voxels } = chunk;\n            const { length } = voxels;\n            for (let i = 0; i < length; i += fields.count) {\n              if (remap) {\n                voxels[i] = remap[voxels[i]];\n              }\n              voxels[i + fields.light] = types[voxels[i]].isLight ? maxLight : 0;\n              voxels[i + fields.sunlight] = 0;\n            }\n            chunk.hasPropagated = false;\n          });\n        }\n      }\n      remeshAll();\n      break;\n    }\n    case 'sunlight':\n      sunlightIntensity = message.intensity;\n      remeshAll();\n      break;\n    case 'clone':\n      if (\n        message.from.y > 0 && message.from.y < maxHeight\n        && message.to.y > 0 && message.to.y < maxHeight\n      ) {\n        const chunk = clone(message.from, message.to);\n        [\n          chunk,\n          ...chunkNeighbors.map(({ x, z }) => ({\n            x: chunk.x + x,\n            z: chunk.z + z,\n          })),\n        ].forEach((chunk) => (\n          remeshDebounced(chunk.x, chunk.z)\n        ));\n      }\n      break;\n    case 'update':\n      if (message.update.y > 0 && message.update.y < maxHeight) {\n        const chunk = update(message.update);\n        [\n          chunk,\n          ...chunkNeighbors.map(({ x, z }) => ({\n            x: chunk.x + x,\n            z: chunk.z + z,\n          })),\n        ].forEach((chunk) => (\n          remeshDebounced(chunk.x, chunk.z)\n        ));\n      }\n      break;\n    case 'pick': {\n      const { block } = message;\n      if (block.y > 0 && block.y < maxHeight) {\n        const chunk = getChunk(\n          Math.floor(block.x / size),\n          Math.floor(block.z / size)\n        );\n        block.x -= size * chunk.x;\n        block.z -= size * chunk.z;\n        context.postMessage({\n          type: 'pick',\n          block: chunk.voxels[getIndex(block.x, block.y, block.z)],\n        });\n      }\n      break;\n    }\n    case 'load':\n      chunks.clear();\n      meshedChunks.clear();\n      types = undefined;\n      message.chunks.forEach(({ x, z, voxels: serialized }) => {\n        const key = `${x}:${z}`;\n        const deserialized = new Uint8ClampedArray(atob(serialized).split('').map((c) => c.charCodeAt(0)));\n        const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n        const heightmap = new Uint8ClampedArray(size ** 2);\n        for (let x = 0, i = 0, j = 0; x < size; x += 1) {\n          for (let y = 0; y < maxHeight; y += 1) {\n            for (let z = 0; z < size; z += 1, i += fields.count, j += 1) {\n              const type = deserialized[j];\n              voxels[i] = type;\n              if (type !== 0) {\n                const heightmapIndex = (x * size) + z;\n                if (heightmap[heightmapIndex] < y) {\n                  heightmap[heightmapIndex] = y;\n                }\n                if (message.types[type - 1].isLight) {\n                  voxels[i + fields.light] = maxLight;\n                }\n              }\n            }\n          }\n        }\n        const chunk = {\n          x,\n          z,\n          voxels,\n          heightmap,\n          hasPropagated: false,\n          key,\n        };\n        chunks.set(key, chunk);\n        meshedChunks.set(key, chunk);\n      });\n      break;\n    case 'save':\n      context.postMessage({\n        type: 'save',\n        chunks: [...meshedChunks.values()].map(({ x, z, voxels }) => {\n          const data = new Uint8ClampedArray(size * size * maxHeight);\n          const { length } = voxels;\n          for (let i = 0, j = 0; i < length; i += 1, j += fields.count) {\n            data[i] = voxels[j];\n          }\n          return {\n            x,\n            z,\n            voxels: btoa(String.fromCharCode.apply(null, data)),\n          };\n        }),\n      });\n      break;\n    case 'computePhysics':\n      context.postMessage({\n        type: 'physics',\n        boxes: computePhysics(message),\n      });\n      break;\n    case 'reset':\n      chunks.clear();\n      meshedChunks.clear();\n      break;\n    default:\n      break;\n  }\n});\n"],"names":["context","self","size","maxHeight","maxLight","fields","type","light","sunlight","count","chunks","Map","types","sunlightIntensity","allocate","cx","cz","x","z","voxels","Uint8ClampedArray","heightmap","hasPropagated","getChunk","key","chunk","get","set","getIndex","y","getVoxelChunk","origin","nx","Math","floor","nz","voxelNeighbors","floodLight","queue","isSunLight","length","shift","forEach","offset","ny","nl","voxel","isTranslucent","push","propagate","lightQueue","sunlightQueue","i","isLight","removeLight","fill","update","current","heightIndex","height","air","getLighting","neighbors","map","n1","hasAO","n2","n3","ao","reduce","n","c","l","s","max","edge","isVisible","neighbor","isCulled","isTransparent","chunkNeighbors","textureY","meshedChunks","mesh","has","getVoxelData","Array","v","subchunk","geometry","opaque","color","position","uv","index","transparent","pushFace","p1","p2","p3","p4","lighting","facing","texture","textures","uvs","from","to","vertices","unshift","pop","vertex","box","top","bottom","south","north","west","east","e","w","t","b","cross","fromY","toY","model","meshes","Float32Array","Uint8Array","Uint16Array","remesh","subchunks","postMessage","buffers","buffer","remeshDebounced","debounce","remeshQueued","values","clear","clearTimeout","setTimeout","remeshAll","list","computePhysics","hasMass","min","Infinity","boxes","j","k","addEventListener","data","message","previousTypes","name","material","slotSize","slotPixel","repropagate","remap","findIndex","id","len","prev","delete","intensity","clone","block","undefined","serialized","deserialized","atob","split","charCodeAt","heightmapIndex","btoa","String","fromCharCode","apply"],"mappings":"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"}