{"version":3,"file":"blocks.worker.js","sources":["../src/workers/blocks.js"],"sourcesContent":["// eslint-disable-next-line no-restricted-globals\nconst context = self;\n\nconst size = 16;\nconst subchunks = 5;\nconst maxHeight = size * subchunks;\nconst maxLight = 15;\nconst fields = {\n  type: 0,\n  light: 1,\n  sunlight: 2,\n  count: 3,\n};\nconst textureWidth = 16;\nconst textureHeight = 16;\n\nconst chunks = new Map();\nconst lightChannels = { light: 1, sunlight: 1 };\nlet types;\n\nconst allocate = (cx, cz) => {\n  const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n  const heightmap = new Uint8ClampedArray(size ** 2);\n  return {\n    x: cx,\n    z: cz,\n    voxels,\n    heightmap,\n    hasPropagated: false,\n  };\n};\n\nconst getChunk = (cx, cz) => {\n  const key = `${cx}:${cz}`;\n  let chunk = chunks.get(key);\n  if (!chunk) {\n    chunk = {\n      ...allocate(cx, cz),\n      key,\n    };\n    chunks.set(key, chunk);\n  }\n  return chunk;\n};\n\nconst getIndex = (x, y, z) => (\n  ((x * size * maxHeight) + (y * size) + z) * fields.count\n);\n\nconst getVoxelChunk = (origin) => (x, z) => {\n  let chunk = origin;\n  const nx = (x < 0 || x >= size) ? Math.floor(x / size) : 0;\n  const nz = (z < 0 || z >= size) ? Math.floor(z / size) : 0;\n  if (nx || nz) {\n    chunk = getChunk(origin.x + nx, origin.z + nz);\n    x -= size * nx;\n    z -= size * nz;\n  }\n  return { chunk, cx: x, cz: z };\n};\n\nconst voxelNeighbors = [\n  { x: 1, y: 0, z: 0 },\n  { x: -1, y: 0, z: 0 },\n  { x: 0, y: 0, z: 1 },\n  { x: 0, y: 0, z: -1 },\n  { x: 0, y: 1, z: 0 },\n  { x: 0, y: -1, z: 0 },\n];\nconst floodLight = (origin, queue, key = 'light') => {\n  const getChunk = getVoxelChunk(origin);\n  const isSunLight = key === 'sunlight';\n  const isTranslucent = (type) => types[type].isTranslucent;\n  while (queue.length) {\n    const { x, y, z } = queue.shift();\n    const { chunk, cx, cz } = getChunk(x, z);\n    const light = chunk.voxels[\n      getIndex(cx, y, cz) + fields[key]\n    ];\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const nl = light - ((isSunLight && offset.y === -1 && light === maxLight) ? 0 : 1);\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      if (\n        !isTranslucent(chunk.voxels[voxel])\n        || (\n          isSunLight\n          && offset.y !== -1\n          && light === maxLight\n          && ny > chunk.heightmap[(cx * size) + cz]\n        )\n        || chunk.voxels[voxel + fields[key]] >= nl\n      ) {\n        return;\n      }\n      chunk.voxels[voxel + fields[key]] = nl;\n      queue.push({ x: nx, y: ny, z: nz });\n    });\n  }\n};\n\nconst propagate = (chunk) => {\n  const lightQueue = [];\n  const sunlightQueue = [];\n  const top = maxHeight - 1;\n  for (let x = 0; x < size; x += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      for (let z = 0; z < size; z += 1) {\n        const i = getIndex(x, y, z);\n        const type = chunk.voxels[i];\n        if (y === top && types[type].isTranslucent) {\n          chunk.voxels[i + fields.sunlight] = maxLight;\n          sunlightQueue.push({ x, y: top, z });\n        } else if (types[type].isLight) {\n          chunk.voxels[i + fields.light] = maxLight;\n          lightQueue.push({ x, y, z });\n        }\n      }\n    }\n  }\n  floodLight(chunk, lightQueue, 'light');\n  floodLight(chunk, sunlightQueue, 'sunlight');\n  chunk.hasPropagated = true;\n};\n\nconst removeLight = (origin, x, y, z, key = 'light') => {\n  const getChunk = getVoxelChunk(origin);\n  const { chunk, cx, cz } = getChunk(x, z);\n  const voxel = getIndex(cx, y, cz);\n  const fill = [];\n  const queue = [];\n  queue.push({\n    x,\n    y,\n    z,\n    light: chunk.voxels[voxel + fields[key]],\n  });\n  chunk.voxels[voxel + fields[key]] = 0;\n  const isSunLight = key === 'sunlight';\n  while (queue.length) {\n    const {\n      x,\n      y,\n      z,\n      light,\n    } = queue.shift();\n    voxelNeighbors.forEach((offset) => {\n      const ny = y + offset.y;\n      if (ny < 0 || ny >= maxHeight) {\n        return;\n      }\n      const nx = x + offset.x;\n      const nz = z + offset.z;\n      const { chunk, cx, cz } = getChunk(nx, nz);\n      const voxel = getIndex(cx, ny, cz);\n      const nl = chunk.voxels[voxel + fields[key]];\n      if (nl === 0) {\n        return;\n      }\n      if (\n        nl < light\n        || (\n          isSunLight\n          && offset.y === -1\n          && light === maxLight\n          && nl === maxLight\n        )\n      ) {\n        queue.push({\n          x: nx,\n          y: ny,\n          z: nz,\n          light: nl,\n        });\n        chunk.voxels[voxel + fields[key]] = 0;\n      } else if (nl >= light) {\n        fill.push({\n          x: nx,\n          y: ny,\n          z: nz,\n        });\n      }\n    });\n  }\n  floodLight(origin, fill, key);\n};\n\nconst update = ({\n  x,\n  y,\n  z,\n  type,\n}) => {\n  const chunk = getChunk(\n    Math.floor(x / size),\n    Math.floor(z / size)\n  );\n  x -= size * chunk.x;\n  z -= size * chunk.z;\n  const {\n    heightmap,\n    voxels,\n    hasPropagated,\n  } = chunk;\n  const voxel = getIndex(x, y, z);\n  const current = voxels[voxel];\n  voxels[voxel] = type;\n  const heightIndex = (x * size) + z;\n  const height = heightmap[heightIndex];\n  if (type === types.air) {\n    if (y === height) {\n      for (let i = y - 1; i >= 0; i -= 1) {\n        if (i === 0 || voxels[getIndex(x, i, z)] !== 0) {\n          heightmap[heightIndex] = i;\n          break;\n        }\n      }\n    }\n  } else if (height < y) {\n    heightmap[heightIndex] = y;\n  }\n  if (hasPropagated) {\n    if (types[current].isLight) {\n      removeLight(chunk, x, y, z);\n    } else if (types[current].isTranslucent && !types[type].isTranslucent) {\n      ['light', 'sunlight'].forEach((key) => {\n        if (voxels[voxel + fields[key]] !== 0) {\n          removeLight(chunk, x, y, z, key);\n        }\n      });\n    }\n    if (types[type].isLight) {\n      voxels[voxel + fields.light] = maxLight;\n      floodLight(chunk, [{ x, y, z }]);\n    } else if (types[type].isTranslucent && !types[current].isTranslucent) {\n      const getChunk = getVoxelChunk(chunk);\n      ['light', 'sunlight'].forEach((key) => {\n        const queue = [];\n        if (key === 'sunlight' && y === maxHeight - 1) {\n          voxels[voxel + fields[key]] = maxLight;\n          queue.push({ x, y, z });\n        } else {\n          voxelNeighbors.forEach((offset) => {\n            const ny = y + offset.y;\n            if (ny < 0 || ny >= maxHeight) {\n              return;\n            }\n            const nx = x + offset.x;\n            const nz = z + offset.z;\n            const { chunk, cx, cz } = getChunk(nx, nz);\n            const voxel = getIndex(cx, ny, cz);\n            const { isLight, isTranslucent } = types[chunk.voxels[voxel]];\n            if (\n              chunk.voxels[voxel + fields[key]] !== 0\n              && (isTranslucent || (isLight && key === 'light'))\n            ) {\n              queue.push({ x: nx, y: ny, z: nz });\n            }\n          });\n        }\n        floodLight(chunk, queue, key);\n      });\n    }\n  }\n  return chunk;\n};\n\nconst clone = ({ x, y, z }, to) => {\n  const chunk = getChunk(\n    Math.floor(x / size),\n    Math.floor(z / size)\n  );\n  x -= size * chunk.x;\n  z -= size * chunk.z;\n  return update({\n    ...to,\n    type: chunk.voxels[getIndex(x, y, z)],\n  });\n};\n\nconst getLighting = ({ light, sunlight }, neighbors) => neighbors.map((neighbors) => {\n  let n1 = types[neighbors[0].type].hasAO;\n  let n2 = types[neighbors[1].type].hasAO;\n  let n3 = (n1 && n2) || types[neighbors[2].type].hasAO;\n  const ao = [n1, n2, n3].reduce((ao, n) => (\n    ao - (n ? 0.1 : 0)\n  ), 1);\n  let c = 1;\n  let l = light;\n  let s = sunlight;\n  n1 = types[neighbors[0].type].isTranslucent;\n  n2 = types[neighbors[1].type].isTranslucent;\n  n3 = (n1 || n2) && types[neighbors[2].type].isTranslucent;\n  [n1, n2, n3].forEach((n, i) => {\n    if (n) {\n      l += neighbors[i].light;\n      s += neighbors[i].sunlight;\n      c += 1;\n    }\n  });\n  return (\n    Math.max(\n      Math.max(l * lightChannels.light, s * lightChannels.sunlight) / c / maxLight,\n      0.01\n    ) * ao\n  );\n});\n\nconst edge = { type: 0, light: 0, sunlight: maxLight };\nconst getVoxelData = (origin) => {\n  const getChunk = getVoxelChunk(origin);\n  return (x, y, z) => {\n    if (y < 0 || y >= maxHeight) {\n      return edge;\n    }\n    const { chunk, cx, cz } = getChunk(x, z);\n    const i = getIndex(cx, y, cz);\n    return {\n      type: chunk.voxels[i],\n      light: chunk.voxels[i + fields.light],\n      sunlight: chunk.voxels[i + fields.sunlight],\n    };\n  };\n};\n\nconst isVisible = (type, neighbor) => (\n  !types[type].isCulled\n  || !types[neighbor].isCulled\n  || (\n    types[neighbor].isGhost\n    && (\n      !types[type].isGhost\n      || type !== neighbor\n    )\n  )\n  || (\n    types[neighbor].isTransparent\n    && (\n      !types[type].isTransparent\n      || type !== neighbor\n    )\n  )\n);\n\nconst chunkNeighbors = [\n  { x: -1, z: -1 },\n  { x: 0, z: -1 },\n  { x: 1, z: -1 },\n  { x: -1, z: 0 },\n  { x: 1, z: 0 },\n  { x: -1, z: 1 },\n  { x: 0, z: 1 },\n  { x: 1, z: 1 },\n];\nconst textureY = {\n  from: 1 / (textureHeight + 2),\n  to: (textureHeight + 1) / (textureHeight + 2),\n};\nconst meshedChunks = new Map();\nconst mesh = (cx, cz) => {\n  const chunk = getChunk(cx, cz);\n  if (!meshedChunks.has(chunk.key)) {\n    meshedChunks.set(chunk.key, chunk);\n  }\n  if (!chunk.hasPropagated) {\n    propagate(chunk);\n  }\n  chunkNeighbors.forEach(({ x, z }) => {\n    const neighbor = getChunk(chunk.x + x, chunk.z + z);\n    if (!neighbor.hasPropagated) {\n      propagate(neighbor);\n    }\n  });\n  const get = getVoxelData(chunk);\n  return [...Array(subchunks)].map((v, subchunk) => {\n    const geometry = ['ghost', 'opaque', 'transparent'].reduce((meshes, key) => {\n      meshes[key] = {\n        color: [],\n        position: [],\n        uv: [],\n        index: [],\n        offset: 0,\n      };\n      return meshes;\n    }, {});\n    const pushFace = (\n      p1,\n      p2,\n      p3,\n      p4,\n      type,\n      lighting,\n      facing\n    ) => {\n      const texture = types[type].textures[facing % 6];\n      const uvs = [\n        [texture.from, facing + textureY.to],\n        [texture.to, facing + textureY.to],\n        [texture.to, facing + textureY.from],\n        [texture.from, facing + textureY.from],\n      ];\n      const vertices = [p1, p2, p3, p4];\n      if (lighting[0] + lighting[2] < lighting[1] + lighting[3]) {\n        lighting.unshift(lighting.pop());\n        uvs.unshift(uvs.pop());\n        vertices.unshift(vertices.pop());\n      }\n      let mesh = geometry.opaque;\n      if (types[type].isGhost) {\n        mesh = geometry.ghost;\n      } else if (types[type].isTransparent) {\n        mesh = geometry.transparent;\n      }\n      lighting.forEach((light) => mesh.color.push(light, light, light));\n      uvs.forEach((uv) => mesh.uv.push(...uv));\n      vertices.forEach((vertex) => mesh.position.push(...vertex));\n      [0, 1, 2, 2, 3, 0].forEach((i) => mesh.index.push(mesh.offset + i));\n      mesh.offset += 4;\n    };\n    const box = (x, y, z, type) => {\n      const top = get(x, y + 1, z);\n      const bottom = get(x, y - 1, z);\n      const south = get(x, y, z + 1);\n      const north = get(x, y, z - 1);\n      const west = get(x - 1, y, z);\n      const east = get(x + 1, y, z);\n      if (isVisible(type, top.type)) {\n        const n = get(x, y + 1, z - 1);\n        const e = get(x + 1, y + 1, z);\n        const w = get(x - 1, y + 1, z);\n        const s = get(x, y + 1, z + 1);\n        pushFace(\n          [x, y + 1, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x + 1, y + 1, z],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            top,\n            [\n              [w, s, get(x - 1, y + 1, z + 1)],\n              [e, s, get(x + 1, y + 1, z + 1)],\n              [e, n, get(x + 1, y + 1, z - 1)],\n              [w, n, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          0\n        );\n      }\n      if (isVisible(type, bottom.type)) {\n        const n = get(x, y - 1, z - 1);\n        const e = get(x + 1, y - 1, z);\n        const w = get(x - 1, y - 1, z);\n        const s = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z],\n          [x + 1, y, z],\n          [x + 1, y, z + 1],\n          [x, y, z + 1],\n          type,\n          getLighting(\n            bottom,\n            [\n              [w, n, get(x - 1, y - 1, z - 1)],\n              [e, n, get(x + 1, y - 1, z - 1)],\n              [e, s, get(x + 1, y - 1, z + 1)],\n              [w, s, get(x - 1, y - 1, z + 1)],\n            ]\n          ),\n          1\n        );\n      }\n      if (isVisible(type, south.type)) {\n        const e = get(x + 1, y, z + 1);\n        const w = get(x - 1, y, z + 1);\n        const t = get(x, y + 1, z + 1);\n        const b = get(x, y - 1, z + 1);\n        pushFace(\n          [x, y, z + 1],\n          [x + 1, y, z + 1],\n          [x + 1, y + 1, z + 1],\n          [x, y + 1, z + 1],\n          type,\n          getLighting(\n            south,\n            [\n              [w, b, get(x - 1, y - 1, z + 1)],\n              [e, b, get(x + 1, y - 1, z + 1)],\n              [e, t, get(x + 1, y + 1, z + 1)],\n              [w, t, get(x - 1, y + 1, z + 1)],\n            ]\n          ),\n          2\n        );\n      }\n      if (isVisible(type, north.type)) {\n        const e = get(x + 1, y, z - 1);\n        const w = get(x - 1, y, z - 1);\n        const t = get(x, y + 1, z - 1);\n        const b = get(x, y - 1, z - 1);\n        pushFace(\n          [x + 1, y, z],\n          [x, y, z],\n          [x, y + 1, z],\n          [x + 1, y + 1, z],\n          type,\n          getLighting(\n            north,\n            [\n              [e, b, get(x + 1, y - 1, z - 1)],\n              [w, b, get(x - 1, y - 1, z - 1)],\n              [w, t, get(x - 1, y + 1, z - 1)],\n              [e, t, get(x + 1, y + 1, z - 1)],\n            ]\n          ),\n          3\n        );\n      }\n      if (isVisible(type, west.type)) {\n        const n = get(x - 1, y, z - 1);\n        const s = get(x - 1, y, z + 1);\n        const t = get(x - 1, y + 1, z);\n        const b = get(x - 1, y - 1, z);\n        pushFace(\n          [x, y, z],\n          [x, y, z + 1],\n          [x, y + 1, z + 1],\n          [x, y + 1, z],\n          type,\n          getLighting(\n            west,\n            [\n              [n, b, get(x - 1, y - 1, z - 1)],\n              [s, b, get(x - 1, y - 1, z + 1)],\n              [s, t, get(x - 1, y + 1, z + 1)],\n              [n, t, get(x - 1, y + 1, z - 1)],\n            ]\n          ),\n          4\n        );\n      }\n      if (isVisible(type, east.type)) {\n        const n = get(x + 1, y, z - 1);\n        const s = get(x + 1, y, z + 1);\n        const t = get(x + 1, y + 1, z);\n        const b = get(x + 1, y - 1, z);\n        pushFace(\n          [x + 1, y, z + 1],\n          [x + 1, y, z],\n          [x + 1, y + 1, z],\n          [x + 1, y + 1, z + 1],\n          type,\n          getLighting(\n            east,\n            [\n              [s, b, get(x + 1, y - 1, z + 1)],\n              [n, b, get(x + 1, y - 1, z - 1)],\n              [n, t, get(x + 1, y + 1, z - 1)],\n              [s, t, get(x + 1, y + 1, z + 1)],\n            ]\n          ),\n          5\n        );\n      }\n    };\n    const cross = (x, y, z, { type, light, sunlight }) => {\n      const lighting = (() => {\n        const lighting = Math.max(\n          Math.max(light * lightChannels.light, sunlight * lightChannels.sunlight) / maxLight,\n          0.01\n        );\n        return [...Array(4)].map(() => lighting);\n      })();\n      pushFace(\n        [x, y, z],\n        [x + 1, y, z + 1],\n        [x + 1, y + 1, z + 1],\n        [x, y + 1, z],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x, y, z + 1],\n        [x + 1, y, z],\n        [x + 1, y + 1, z],\n        [x, y + 1, z + 1],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x + 1, y, z + 1],\n        [x, y, z],\n        [x, y + 1, z],\n        [x + 1, y + 1, z + 1],\n        type,\n        lighting,\n        6\n      );\n      pushFace(\n        [x + 1, y, z],\n        [x, y, z + 1],\n        [x, y + 1, z + 1],\n        [x + 1, y + 1, z],\n        type,\n        lighting,\n        6\n      );\n    };\n    const fromY = subchunk * size;\n    const toY = (subchunk + 1) * size;\n    for (let x = 0; x < size; x += 1) {\n      for (let y = fromY; y < toY; y += 1) {\n        for (let z = 0; z < size; z += 1) {\n          const voxel = get(x, y, z);\n          if (voxel.type !== 0) {\n            switch (types[voxel.type].model) {\n              case 'cross':\n                cross(x, y, z, voxel);\n                break;\n              default:\n                box(x, y, z, voxel.type);\n                break;\n            }\n          }\n        }\n      }\n    }\n    return ['ghost', 'opaque', 'transparent'].reduce((meshes, key) => {\n      const {\n        color,\n        position,\n        uv,\n        index,\n      } = geometry[key];\n      meshes[key] = {\n        color: new Float32Array(color),\n        position: new Uint8Array(position),\n        uv: new Float32Array(uv),\n        index: new Uint16Array(index),\n      };\n      return meshes;\n    }, {});\n  });\n};\n\nconst remesh = (x, z) => {\n  const subchunks = mesh(x, z);\n  context.postMessage({\n    type: 'chunk',\n    position: { x, z },\n    subchunks,\n  }, subchunks.reduce((buffers, meshes) => {\n    ['ghost', 'opaque', 'transparent'].forEach((mesh) => {\n      mesh = meshes[mesh];\n      buffers.push(\n        mesh.color.buffer,\n        mesh.position.buffer,\n        mesh.uv.buffer,\n        mesh.index.buffer\n      );\n    });\n    return buffers;\n  }, []));\n};\n\nconst remeshDebounced = (() => {\n  let debounce;\n  const queue = new Map();\n  const remeshQueued = () => {\n    [...queue.values()].forEach((chunk) => (\n      remesh(chunk.x, chunk.z)\n    ));\n    queue.clear();\n  };\n  return (x, z) => {\n    queue.set(`${x}:${z}`, { x, z });\n    if (debounce) {\n      clearTimeout(debounce);\n    }\n    debounce = setTimeout(remeshQueued, 0);\n  };\n})();\n\nconst remeshAll = () => {\n  const list = [...meshedChunks.values()];\n  if (!list.length) {\n    remeshDebounced(0, 0);\n    return;\n  }\n  list.forEach((chunk) => (\n    remeshDebounced(chunk.x, chunk.z)\n  ));\n};\n\nconst computeLightmap = ({ offset = { x: -8, y: -1, z: -8 } }) => {\n  const getLight = (x, y, z) => {\n    const cx = Math.floor(x / size);\n    const cz = Math.floor(z / size);\n    const key = `${cx}:${cz}`;\n    const chunk = meshedChunks.get(key);\n    if (!chunk) {\n      return 0;\n    }\n    x -= size * chunk.x;\n    z -= size * chunk.z;\n    const voxel = getIndex(x, y, z);\n    const type = types[chunk.voxels[voxel]];\n    if (!type.isTranslucent) {\n      return 0;\n    }\n    return Math.floor((Math.max(\n      chunk.voxels[voxel + fields.light] * lightChannels.light,\n      chunk.voxels[voxel + fields.sunlight] * lightChannels.sunlight\n    ) * 0xFF) / maxLight);\n  };\n\n  const { min, max } = [...meshedChunks.values()].reduce(({ min, max }, { x, z }) => ({\n    min: { x: Math.min(min.x, x * size), z: Math.min(min.z, z * size) },\n    max: { x: Math.max(max.x, (x + 1) * size), z: Math.max(max.z, (z + 1) * size) },\n  }), { min: { x: Infinity, z: Infinity }, max: { x: -Infinity, z: -Infinity } });\n\n  const volume = {\n    x: max.x - min.x,\n    y: maxHeight,\n    z: max.z - min.z,\n  };\n\n  const lightmap = Array(volume.x * volume.y * volume.z);\n\n  // eslint-disable-next-line prefer-destructuring\n  for (let z = min.z, i = 0; z < max.z; z += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      // eslint-disable-next-line prefer-destructuring\n      for (let x = min.x; x < max.x; x += 1, i += 1) {\n        lightmap[i] = String.fromCharCode(getLight(x, y, z));\n      }\n    }\n  }\n\n  return {\n    data: btoa(lightmap.join('')),\n    origin: {\n      x: min.x + offset.x,\n      y: offset.y,\n      z: min.z + offset.z,\n    },\n    size: volume,\n  };\n};\n\nconst computePhysics = ({ offset = { x: -8, y: -1, z: -8 } }) => {\n  const hasMass = (x, y, z) => {\n    if (y < 0 || y >= maxHeight) {\n      return false;\n    }\n    const cx = Math.floor(x / size);\n    const cz = Math.floor(z / size);\n    const key = `${cx}:${cz}`;\n    const chunk = meshedChunks.get(key);\n    if (!chunk) {\n      return false;\n    }\n    x -= size * chunk.x;\n    z -= size * chunk.z;\n    const type = chunk.voxels[getIndex(x, y, z)];\n    return type !== 0 && !types[type].isGhost && types[type].model !== 'cross';\n  };\n\n  const { min, max } = [...meshedChunks.values()].reduce(({ min, max }, { x, z }) => ({\n    min: { x: Math.min(min.x, x * size), z: Math.min(min.z, z * size) },\n    max: { x: Math.max(max.x, (x + 1) * size), z: Math.max(max.z, (z + 1) * size) },\n  }), { min: { x: Infinity, z: Infinity }, max: { x: -Infinity, z: -Infinity } });\n\n  const boxes = [];\n  const map = new Map();\n\n  // eslint-disable-next-line prefer-destructuring\n  for (let x = min.x; x < max.x; x += 1) {\n    for (let y = 0; y < maxHeight; y += 1) {\n      // eslint-disable-next-line prefer-destructuring\n      for (let z = min.z; z < max.z; z += 1) {\n        if (hasMass(x, y, z) && !map.has(`${x}:${y}:${z}`)) {\n          const box = {\n            position: { x, y, z },\n            size: { x: 0, y: 0, z: 0 },\n          };\n          boxes.push(box);\n\n          for (let i = x + 1; i <= max.x; i += 1) {\n            if (!hasMass(i, y, z) || map.has(`${i}:${y}:${z}`)) {\n              box.size.x = i - x;\n              break;\n            }\n          }\n\n          box.size.y = maxHeight - y;\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y + 1; j <= y + box.size.y; j += 1) {\n              if (!hasMass(i, j, z) || map.has(`${i}:${j}:${z}`)) {\n                box.size.y = j - y;\n              }\n            }\n          }\n\n          box.size.z = max.z - z;\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y; j < y + box.size.y; j += 1) {\n              for (let k = z + 1; k <= z + box.size.z; k += 1) {\n                if (!hasMass(i, j, k) || map.has(`${i}:${j}:${k}`)) {\n                  box.size.z = k - z;\n                }\n              }\n            }\n          }\n\n          for (let i = x; i < x + box.size.x; i += 1) {\n            for (let j = y; j < y + box.size.y; j += 1) {\n              for (let k = z; k < z + box.size.z; k += 1) {\n                map.set(`${i}:${j}:${k}`, true);\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return boxes.map(({ position, size }) => [\n    [position.x + offset.x, position.y + offset.y, position.z + offset.z],\n    [size.x, size.y, size.z],\n  ]);\n};\n\ncontext.addEventListener('message', ({ data: message }) => {\n  switch (message.type) {\n    case 'types': {\n      const previousTypes = types;\n      const textures = { opaque: 0, transparent: 0 };\n      types = [\n        {\n          name: 'Air',\n          isLight: false,\n          isTranslucent: true,\n        },\n        ...message.types\n          .map((type) => {\n            const material = type.isTransparent ? 'transparent' : 'opaque';\n            const isCross = type.model === 'cross';\n            const index = textures[material];\n            if (!type.isGhost) {\n              textures[material] += isCross ? 1 : 3;\n            }\n            return {\n              ...type,\n              hasAO: !isCross,\n              isCulled: !isCross,\n              isTranslucent: isCross || type.isTransparent,\n              textures: isCross ? [index] : [\n                index,\n                index + 2,\n                index + 1,\n                index + 1,\n                index + 1,\n                index + 1,\n              ],\n            };\n          })\n          .map((type) => ({\n            ...type,\n            textures: type.textures.map((index) => {\n              const slotSize = 1 / textures[type.isTransparent ? 'transparent' : 'opaque'];\n              const slotPixel = slotSize / (textureWidth + 2);\n              const from = (index * slotSize) + slotPixel;\n              return {\n                from,\n                to: from + (slotPixel * textureWidth),\n              };\n            }),\n          })),\n      ];\n      if (previousTypes) {\n        let repropagate = false;\n        let remap = false;\n        if (types.length < previousTypes.length) {\n          repropagate = true;\n          remap = previousTypes.map(({ key }) => {\n            if (!key) {\n              return 0;\n            }\n            const index = types.findIndex(({ key: id }) => (id === key));\n            return ~index ? index : 0;\n          });\n        } else {\n          const len = previousTypes.length;\n          for (let i = 0; i < len; i += 1) {\n            const prev = previousTypes[i];\n            const current = types[i];\n            if (\n              prev.model !== current.model\n              || prev.isGhost !== current.isGhost\n              || prev.isLight !== current.isLight\n              || prev.isTransparent !== current.isTransparent\n            ) {\n              repropagate = true;\n              break;\n            }\n          }\n        }\n        if (repropagate) {\n          [...chunks.values()].forEach(({ key }) => {\n            if (!meshedChunks.has(key)) {\n              chunks.delete(key);\n            }\n          });\n          [...meshedChunks.values()].forEach((chunk) => {\n            const { voxels } = chunk;\n            const { length } = voxels;\n            for (let i = 0; i < length; i += fields.count) {\n              if (remap) {\n                voxels[i] = remap[voxels[i]];\n              }\n              voxels[i + fields.light] = types[voxels[i]].isLight ? maxLight : 0;\n              voxels[i + fields.sunlight] = 0;\n            }\n            chunk.hasPropagated = false;\n          });\n        }\n      }\n      remeshAll();\n      break;\n    }\n    case 'lighting':\n      lightChannels.light = message.channels.light;\n      lightChannels.sunlight = message.channels.sunlight;\n      remeshAll();\n      break;\n    case 'clone':\n      if (\n        message.from.y > 0 && message.from.y < maxHeight\n        && message.to.y > 0 && message.to.y < maxHeight\n      ) {\n        const chunk = clone(message.from, message.to);\n        [\n          chunk,\n          ...chunkNeighbors.map(({ x, z }) => ({\n            x: chunk.x + x,\n            z: chunk.z + z,\n          })),\n        ].forEach((chunk) => (\n          remeshDebounced(chunk.x, chunk.z)\n        ));\n      }\n      break;\n    case 'update':\n      if (message.update.y > 0 && message.update.y < maxHeight) {\n        const chunk = update(message.update);\n        [\n          chunk,\n          ...chunkNeighbors.map(({ x, z }) => ({\n            x: chunk.x + x,\n            z: chunk.z + z,\n          })),\n        ].forEach((chunk) => (\n          remeshDebounced(chunk.x, chunk.z)\n        ));\n      }\n      break;\n    case 'pick': {\n      const { block } = message;\n      if (block.y > 0 && block.y < maxHeight) {\n        const chunk = getChunk(\n          Math.floor(block.x / size),\n          Math.floor(block.z / size)\n        );\n        block.x -= size * chunk.x;\n        block.z -= size * chunk.z;\n        context.postMessage({\n          type: 'pick',\n          block: chunk.voxels[getIndex(block.x, block.y, block.z)],\n        });\n      }\n      break;\n    }\n    case 'load':\n      chunks.clear();\n      meshedChunks.clear();\n      types = undefined;\n      message.chunks.forEach(({ x, z, voxels: serialized }) => {\n        const key = `${x}:${z}`;\n        const deserialized = new Uint8ClampedArray(atob(serialized).split('').map((c) => c.charCodeAt(0)));\n        const voxels = new Uint8ClampedArray(size * size * maxHeight * fields.count);\n        const heightmap = new Uint8ClampedArray(size ** 2);\n        for (let x = 0, i = 0, j = 0; x < size; x += 1) {\n          for (let y = 0; y < maxHeight; y += 1) {\n            for (let z = 0; z < size; z += 1, i += fields.count, j += 1) {\n              const type = deserialized[j];\n              voxels[i] = type;\n              if (type !== 0) {\n                const heightmapIndex = (x * size) + z;\n                if (heightmap[heightmapIndex] < y) {\n                  heightmap[heightmapIndex] = y;\n                }\n                if (message.types[type - 1].isLight) {\n                  voxels[i + fields.light] = maxLight;\n                }\n              }\n            }\n          }\n        }\n        const chunk = {\n          x,\n          z,\n          voxels,\n          heightmap,\n          hasPropagated: false,\n          key,\n        };\n        chunks.set(key, chunk);\n        meshedChunks.set(key, chunk);\n      });\n      break;\n    case 'save':\n      context.postMessage({\n        type: 'save',\n        chunks: [...meshedChunks.values()].map(({ x, z, voxels }) => {\n          const data = new Uint8ClampedArray(size * size * maxHeight);\n          const { length } = voxels;\n          for (let i = 0, j = 0; i < length; i += 1, j += fields.count) {\n            data[i] = voxels[j];\n          }\n          return {\n            x,\n            z,\n            voxels: btoa(String.fromCharCode.apply(null, data)),\n          };\n        }),\n      });\n      break;\n    case 'computeLightmap':\n      context.postMessage({\n        type: 'lightmap',\n        lightmap: computeLightmap(message),\n      });\n      break;\n    case 'computePhysics':\n      context.postMessage({\n        type: 'physics',\n        boxes: computePhysics(message),\n      });\n      break;\n    case 'reset':\n      chunks.clear();\n      meshedChunks.clear();\n      break;\n    default:\n      break;\n  }\n});\n"],"names":["context","self","size","maxHeight","maxLight","fields","type","light","sunlight","count","chunks","Map","lightChannels","types","allocate","cx","cz","x","z","voxels","Uint8ClampedArray","heightmap","hasPropagated","getChunk","key","chunk","get","set","getIndex","y","getVoxelChunk","origin","nx","Math","floor","nz","voxelNeighbors","floodLight","queue","isSunLight","length","shift","forEach","offset","ny","nl","voxel","isTranslucent","push","propagate","lightQueue","sunlightQueue","i","isLight","removeLight","fill","update","current","heightIndex","height","air","getLighting","neighbors","map","n1","hasAO","n2","n3","ao","reduce","n","c","l","s","max","edge","isVisible","neighbor","isCulled","isGhost","isTransparent","chunkNeighbors","textureY","meshedChunks","mesh","has","getVoxelData","Array","v","subchunk","geometry","meshes","color","position","uv","index","pushFace","p1","p2","p3","p4","lighting","facing","texture","textures","uvs","from","to","vertices","unshift","pop","opaque","ghost","transparent","vertex","box","top","bottom","south","north","west","east","e","w","t","b","cross","fromY","toY","model","Float32Array","Uint8Array","Uint16Array","remeshDebounced","debounce","remeshQueued","values","subchunks","postMessage","buffers","buffer","clear","clearTimeout","setTimeout","remeshAll","list","computeLightmap","getLight","min","Infinity","volume","lightmap","String","fromCharCode","data","btoa","join","computePhysics","hasMass","boxes","j","k","addEventListener","message","previousTypes","name","material","isCross","slotSize","slotPixel","repropagate","remap","findIndex","id","len","prev","delete","channels","clone","block","undefined","serialized","deserialized","atob","split","charCodeAt","heightmapIndex","apply"],"mappings":"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"}