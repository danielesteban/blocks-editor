{
  "version": 3,
  "file": "app.css",
  "sources": [
    "app.svelte",
    "blockEditor.svelte",
    "blockTypes.svelte",
    "blocks.svelte",
    "color.svelte",
    "colorPicker.svelte",
    "help.svelte",
    "lighting.svelte",
    "pixels.svelte",
    "scriptEditor.svelte",
    "texture.svelte",
    "tools.svelte",
    "main.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { tick } from 'svelte';\n  import Link from './components/link.svelte';\n  import Main from './routes/main.svelte';\n  import router from './stores/router';\n\n  router.init();\n\n  let component;\n  $: switch ($router.id) {\n    case '':\n      component = Main;\n      break;\n    default:\n      tick().then(() => router.replace('/'));\n      break;\n  }\n\n  const onContextMenu = (e) => e.preventDefault();\n</script>\n\n<svelte:window on:contextmenu={onContextMenu} />\n\n<app>\n  <route>\n    <svelte:component\n      this={component}\n      {...($router.params ? { params: $router.params } : {})}\n    />\n  </route>\n  <toolbar>\n    <div>\n      <brand>\n        <Link path=\"/\">\n          blocks-editor\n        </Link>\n      </brand>\n    </div>\n    <div>\n      <github>\n        <a href=\"https://github.com/danielesteban/blocks-editor\" rel=\"noopener noreferrer\" target=\"_blank\">\n          view source\n        </a>\n      </github>\n      <credits>\n        <a href=\"https://dani.gatunes.com/\" rel=\"noopener noreferrer\" target=\"_blank\">\n          dani@gatunes\n        </a> Â© 2020\n      </credits>\n    </div>\n  </toolbar>\n</app>\n\n<style>\n  app {\n    display: flex;\n    flex-direction: column;\n    height: 100vh;\n  }\n\n  route {\n    flex-grow: 1;\n    display: block;\n    overflow: overlay;\n  }\n\n  toolbar {\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    height: 40px;\n    padding: 0 1rem;\n    box-sizing: border-box;\n    background: #222;\n    border-top: 2px solid #000;\n  }\n\n  toolbar > div {\n    display: flex;\n    align-items: center;\n  }\n\n  brand {\n    letter-spacing: 0.2rem;\n  }\n\n  credits {\n    border-left: 1px solid #888;\n    color: #ccc;\n    margin-left: 1em;\n    padding-left: 1em;\n  }\n</style>\n",
    "<script>\n  import ColorPicker from './colorPicker.svelte';\n  import Pixels from './pixels.svelte';\n\n  export let editor;\n  export let colors;\n  export let textures;\n  export let types;\n\n  $: type = $types[$editor];\n  $: typeTextures = $textures[$editor];\n\n  let texture = 'top';\n  $: if (type.model === 'cross' && texture !== 'top') {\n    texture = 'top';\n  }\n  $: pixels = typeTextures[texture];\n\n  let lastColor;\n  const onTextureUpdate = ({ detail: pixels }) => {\n    textures.update($editor, texture, pixels);\n    if (\n      $colors.current !== lastColor\n      && !(\n        $colors.palette.find(([r, g, b, a]) => (\n          $colors.current[0] === r\n          && $colors.current[1] === g\n          && $colors.current[2] === b\n          && $colors.current[3] === a\n        ))\n      )\n    ) {\n      lastColor = $colors.current;\n      colors.addToPalette($colors.current);\n    }\n  };\n</script>\n\n<block>\n  <name>\n    <input\n      type=\"text\"\n      value={type.name}\n      on:change={({ target: { value } }) => { types.update($editor, 'name', value); }}\n    />\n  </name>\n  <modifiers>\n    <label>\n      Model:\n      <!-- svelte-ignore a11y-no-onchange -->\n      <select\n        value={type.model}\n        on:change={({ target: { value } }) => { types.update($editor, 'model', value); }}\n      >\n        <option value=\"box\">\n          Box\n        </option>\n        <option value=\"cross\">\n          Cross\n        </option>\n      </select>\n    </label>\n    <label>\n      <input\n        type=\"checkbox\"\n        checked={type.isLight}\n        on:change={({ target: { checked } }) => { types.update($editor, 'isLight', checked); }}\n      />\n      Emits light\n    </label>\n    <label>\n      <input\n        type=\"checkbox\"\n        checked={type.isTransparent}\n        on:change={({ target: { checked } }) => { types.update($editor, 'isTransparent', checked); }}\n      />\n      Transparent\n    </label>\n  </modifiers>\n</block>\n<textures>\n  <tabs>\n    <tab\n      class:selected={texture === 'top'}\n      on:click={() => { texture = 'top'; }}\n    >\n      Top Texture  \n    </tab>\n    <tab\n      class:disabled={type.model === 'cross'}\n      class:selected={texture === 'side'}\n      on:click={() => { texture = 'side'; }}\n    >\n      Side Texture  \n    </tab>\n    <tab\n      class:disabled={type.model === 'cross'}\n      class:selected={texture === 'bottom'}\n      on:click={() => { texture = 'bottom'; }}\n    >\n      Bottom Texture  \n    </tab>\n  </tabs>\n  <texture>\n    <Pixels\n      brush={$colors.brush}\n      color={$colors.current}\n      isTransparent={type.isTransparent}\n      noise={$colors.noise}\n      pixels={pixels}\n      on:update={onTextureUpdate}\n      showGrid\n    />\n  </texture>\n</textures>\n<ColorPicker\n  colors={colors}\n  enableOpacity={type.isTransparent}\n/>\n\n<style>\n  block, textures {\n    display: flex;\n    flex-direction: column;\n    background: #222;\n  }\n\n  tabs {\n    display: flex;\n    align-items: center;\n    background: #222;\n    border-bottom: 2px solid #111;\n  }\n\n  tab {\n    padding: 0.5rem 1rem;\n    border-right: 1px solid #111;\n    cursor: pointer;\n  }\n\n  tab.disabled {\n    color: #666;\n    cursor: default;\n  }\n\n  tab.selected {\n    cursor: default;\n    background: #333;\n  }\n\n  texture {\n    display: block;\n    background: #000;\n    padding: 0.5rem;\n    border-bottom: 2px solid #111;\n  }\n\n  name, modifiers {\n    box-sizing: border-box;\n    display: flex;\n    align-items: center;\n    border-bottom: 2px solid #111;\n  }\n\n  name > input {\n    width: 100%;\n  }\n\n  modifiers {\n    justify-content: space-evenly;\n    padding: 0.5rem 0;\n  }\n\n  modifiers > label {\n    display: block;\n    cursor: pointer;\n  }\n</style>\n",
    "<script>\n  import Texture from './texture.svelte';\n\n  export let editor;\n  export let selected;\n  export let textures;\n  export let types;\n\n  const onEdit = (type) => {\n    if ($editor !== type) {\n      editor.open(type);\n    }\n  };\n\n  const onClone = (type) => {\n    types.clone(type);\n    selected = $types.length - 1;\n    editor.open(selected);\n  };\n\n  const onRemove = (type) => {\n    if (!confirm('Are you sure?')) {\n      return;\n    }\n    editor.close();\n    selected = 0;\n    types.remove(type);\n  };\n</script>\n\n{#each $types as type, i (type.key)}\n  <blockType\n    class:selected={selected === i}\n    on:click={() => {\n      selected = i;\n      if ($editor !== selected) {\n        editor.close();\n      }\n    }}\n  >\n    <texture>\n      <Texture\n        isTransparent={type.isTransparent}\n        pixels={$textures[i].top}\n      />\n    </texture>\n    <info>\n      <name>{type.name}</name>\n      <modifiers>\n        {type.isTransparent ? 'transparent' : ''}\n        {type.isTransparent && type.isLight ? ' | ' : ''}\n        {type.isLight ? 'emits light' : ''}\n        &nbsp;\n      </modifiers>\n      <actions>\n        <button on:click={() => onEdit(i)}>\n          Edit\n        </button>\n        <button on:click={(e) => { e.stopPropagation(); onClone(i); }}>\n          Clone\n        </button>\n        <button\n          on:click={(e) => { e.stopPropagation(); onRemove(i); }}\n          disabled={$types.length <= 1}\n        >\n          Remove\n        </button>\n      </actions>\n    </info>\n  </blockType>\n{/each}\n\n<style>\n  blockType {\n    display: flex;\n    padding: 1rem;\n    background: #222;\n    border-bottom: 1px solid #111;\n  }\n\n  blockType.selected {\n    background: #363;\n  }\n\n  texture {\n    display: block;\n    width: 64px;\n    height: 64px;\n    background: #000;\n    border: 4px solid #222;\n    box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);\n    margin-right: 1rem;\n  }\n\n  info {\n    display: block;\n    overflow: hidden;\n    flex-grow: 1;\n  }\n\n  name {\n    display: block;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n  }\n\n  modifiers {\n    display: block;\n    color: #999;\n  }\n\n  actions {\n    display: flex;\n    width: 100%;\n    justify-content: space-between;\n    padding: 0.25rem 0;\n  }\n  \n  actions > button {\n    padding: 0.125rem 0.75rem;\n  }\n</style>",
    "<script>\n  import { onMount, onDestroy } from 'svelte';\n  import { Vector3 } from 'three';\n  import { GLTFExporter } from 'three/examples/jsm/exporters/GLTFExporter';\n  import { SimplexNoise } from 'three/examples/jsm/math/SimplexNoise';\n  import DesktopControls from './controls.svelte';\n  import Help from './help.svelte';\n  import Renderer from './renderer.svelte';\n  import Grid from '../renderables/grid';\n  import Voxels from '../renderables/voxels';\n\n  export let atlas;\n  export let editor;\n  export let lighting;\n  export let script;\n  export let selected;\n  export let types;\n\n  let controls;\n  let isLocked;\n  let scene;\n\n  const initialPosition = { x: 8, y: 8, z: 32 };\n  const worker = new Worker('blocks.worker.js');\n  const subchunks = new Map();\n  const children = [];\n  worker.addEventListener('message', ({ data: message }) => {\n    switch (message.type) {\n      case 'chunk':\n        message.subchunks.forEach((geometries, subchunk) => {\n          subchunk = {\n            ...message.position,\n            y: subchunk,\n          };\n          const key = `${subchunk.x}:${subchunk.y}:${subchunk.z}`;\n          let voxels = subchunks.get(key);\n          if (!voxels) {\n            voxels = new Voxels(subchunk);\n            scene.add(voxels);\n            subchunks.set(key, voxels);\n          }\n          voxels.update(geometries);\n        });\n        children.length = 0;\n        [...subchunks.values()].forEach(({ meshes }) => {\n          if (meshes.opaque.visible) {\n            children.push(meshes.opaque);\n          }\n          if (meshes.transparent.visible) {\n            children.push(meshes.transparent);\n          }\n        });\n        break;\n      case 'physics':\n        onPhysics(message.boxes);\n        break;\n      case 'pick':\n        onPick(message.block);\n        break;\n      case 'save':\n        onSave(message.chunks);\n        break;\n      default:\n        break;\n    }\n  });\n\n  $: Voxels.updateAtlas($atlas);\n\n  $: worker.postMessage({\n    type: 'types',\n    types: $types,\n  });\n\n  $: worker.postMessage({\n    type: 'sunlight',\n    intensity: $lighting.sunlight,\n  });\n\n  const loader = document.createElement('input');\n  loader.accept = 'application/json';\n  loader.type = 'file';\n  loader.style.display = 'none';\n  document.body.appendChild(loader);\n  export const load = () => {\n    loader.onchange = ({ target: { files: [file] } }) => {\n      const reader = new FileReader();\n      reader.onload = () => {\n        let serialized;\n        try {\n          serialized = JSON.parse(reader.result);\n        } catch (e) {\n          return;\n        }\n        types.deserialize(serialized.types);\n        editor.close();\n        $lighting = serialized.lighting;\n        $script = serialized.script;\n        selected = 0;\n        children.length = 0;\n        [...subchunks.values()].forEach(({ meshes }) => {\n          meshes.opaque.visible = false;\n          meshes.transparent.visible = false;\n        });\n        worker.postMessage({\n          type: 'load',\n          types: $types,\n          chunks: serialized.chunks,\n        });\n      };\n      reader.readAsText(file);\n      loader.value = null;\n    };\n    loader.click();\n  };\n\n  const downloader = document.createElement('a');\n  downloader.style.display = 'none';\n  document.body.appendChild(downloader);\n\n  let saving;\n  const onSave = (chunks) => {\n    const serialized = JSON.stringify({\n      types: types.serialize(),\n      chunks,\n      lighting: $lighting,\n      script: $script,\n    });\n    saving.forEach((resolve) => resolve(serialized));\n    saving = undefined;\n  };\n  export const save = (download) => new Promise((resolve) => {\n    if (saving) {\n      saving.push(resolve);\n      return;\n    }\n    saving = [resolve];\n    worker.postMessage({\n      type: 'save',\n    });\n  })\n    .then((serialized) => {\n      if (download) {\n        downloader.download = `${download}.json`;\n        downloader.href = URL.createObjectURL(new Blob([serialized], { type: 'application/json' }));\n        downloader.click();\n      }\n      return serialized;\n    });\n\n  export const reset = () => {\n    children.length = 0;\n    [...subchunks.values()].forEach(({ meshes }) => {\n      meshes.opaque.visible = false;\n      meshes.transparent.visible = false;\n    });\n    worker.postMessage({\n      type: 'reset',\n    });\n  };\n  \n  export const runScript = () => (new Function([\n    'const [noise, update] = arguments;',\n    $script,\n  ].join('\\n')))(\n    new SimplexNoise(),\n    (x, y, z, type) => worker.postMessage({\n      type: 'update',\n      update: { x, y: y + 1, z, type },\n    })\n  );\n\n  const exporter = new GLTFExporter();\n  export const gltf = (download) => {\n    const materials = Voxels.getExportableMaterials();\n    return new Promise((resolve) => exporter.parse((\n      [...subchunks.values()]\n        .filter(({ meshes: { opaque, transparent } }) => (\n          opaque.visible || transparent.visible\n        ))\n        .map((mesh) => mesh.clone(materials))\n    ), (buffer) => {\n      const blob = new Blob([buffer], { type: 'model/gltf-binary' });\n      if (download) {\n        downloader.download = `${download}.glb`;\n        downloader.href = URL.createObjectURL(blob);\n        downloader.click();\n      }\n      resolve(blob);\n    }, {\n      binary: true,\n    }));\n  };\n\n  let computing;\n  const onPhysics = (boxes) => {\n    const serialized = JSON.stringify(boxes);\n    computing.forEach((resolve) => resolve(serialized));\n    computing = undefined;\n  };\n  export const computePhysics = (download) => new Promise((resolve) => {\n    if (computing) {\n      computing.push(resolve);\n      return;\n    }\n    computing = [resolve];\n    worker.postMessage({\n      type: 'computePhysics',\n    });\n  })\n    .then((serialized) => {\n      if (download) {\n        downloader.download = `${download}.json`;\n        downloader.href = URL.createObjectURL(new Blob([serialized], { type: 'application/json' }));\n        downloader.click();\n      }\n      return serialized;\n    });\n\n  const grid = new Grid();\n\n  onMount(() => {\n    scene.add(grid);\n  });\n\n  onDestroy(() => {\n    document.body.removeChild(loader);\n    document.body.removeChild(downloader);\n    worker.terminate();\n  });\n\n  const blockFacings = [\n    new Vector3(0, 1, 0),\n    new Vector3(0, -1, 0),\n    new Vector3(0, 0, 1),\n    new Vector3(0, 0, -1),\n    new Vector3(-1, 0, 0),\n    new Vector3(1, 0, 0),\n  ];\n  const getBlock = (raycaster, neighbor) => {\n    const hit = raycaster.intersectObjects(children)[0] || false;\n    if (!hit) {\n      if (neighbor) {\n        const hit = raycaster.intersectObject(grid)[0] || false;\n        if (hit) {\n          return hit.point\n            .addScaledVector(blockFacings[0], 0.5)\n            .floor();\n        }\n      }\n      return false;\n    }\n    const { point, uv } = hit;\n    const normal = blockFacings[Math.floor(uv.y)];\n    if (!normal && neighbor) {\n      return false;\n    }\n    if (normal) {\n      point.addScaledVector(normal, (neighbor ? 1 : -1) * 0.5);\n    }\n    return point.floor();\n  };\n\n  const onButtons = ({ detail: { buttons, raycaster } }) => {\n    const {\n      primaryDown: isPlacing,\n      secondaryDown: isRemoving,\n      tertiaryDown: isPicking,\n    } = buttons;\n    if (!isPlacing && !isRemoving && !isPicking) {\n      return;\n    }\n    const block = getBlock(raycaster, !(isPicking || isRemoving));\n    if (!block) {\n      return;\n    }\n    if (isPicking) {\n      worker.postMessage({\n        type: 'pick',\n        block: {\n          x: block.x,\n          y: block.y + 1,\n          z: block.z,\n        },\n      });\n      return;\n    }\n    worker.postMessage({\n      type: 'update',\n      update: {\n        x: block.x,\n        y: block.y + 1,\n        z: block.z,\n        type: isRemoving ? 0 : selected + 1,\n      },\n    });\n  };\n\n  const onPick = (type) => {\n    selected = type - 1;\n  };\n</script>\n\n<DesktopControls\n  bind:this={controls}\n  bind:isLocked={isLocked}\n  on:buttons={onButtons}\n/>\n<Renderer\n  bind:scene={scene}\n  controls={controls}\n  initialPosition={initialPosition}\n/>\n\n<Help isLocked={isLocked} />\n\n{#if isLocked}\n  <crosshair>\n    <div></div>\n    <div></div>\n  </crosshair>\n{/if}\n\n<style>\n  crosshair {\n    opacity: 0.3;\n  }\n\n  crosshair > div {\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    background: #fff;\n  }\n\n  crosshair > div:nth-child(1) {\n    width: 8px;\n    height: 2px;\n  }\n\n  crosshair > div:nth-child(2) {\n    width: 2px;\n    height: 8px;\n  }\n</style>\n",
    "<script>\n  export let color;\n</script>\n\n<color>\n  <bg>\n    <div\n      style=\"background: rgb(255, 255, 255)\"\n    />\n    <div\n      style=\"background: rgb(204, 204, 204)\"\n    />\n    <div\n      style=\"background: rgb(204, 204, 204)\"\n    />\n    <div\n      style=\"background: rgb(255, 255, 255)\"\n    />\n  </bg>\n  <tint\n    style=\"background: rgba({color.slice(0, 3).join(',')},{color[3] / 0xFF})\"\n  />\n</color>\n\n<style>\n  color {\n    display: block;\n    position: relative;\n    width: 24px;\n    height: 24px;\n    border: 1px solid #222;\n    border-radius: 4px;\n    box-shadow: 0 0 8px rgba(0, 0, 0, 0.5);\n    overflow: hidden;\n  }\n\n  bg, tint {\n    display: flex;\n    flex-wrap: wrap;\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n  }\n\n  bg > div {\n    display: block;\n    width: 12px;\n    height: 12px;\n  }\n</style>\n",
    "<script>\n  import { onMount } from 'svelte';\n  import Color from './color.svelte';\n  \n  export let colors;\n  export let enableOpacity;\n\n  const width = 320;\n  const height = 300;\n\n  const area = {\n    x: 16,\n    y: 16,\n    width: width - 80,\n    height: height - 32,\n  };\n  const strip = {\n    x: width - 48,\n    y: 16,\n    width: 32,\n    height: height - 32,\n  };\n\n  let canvas;\n  let ctx;\n\n  const draw = () => {\n    ctx.clearRect(0, 0, width, height);\n    {\n      ctx.save();\n      const {\n        x,\n        y,\n        width,\n        height,\n      } = area;\n      ctx.translate(x, y);\n      ctx.fillStyle = `rgb(${$colors.area.join(',')})`;\n      ctx.fillRect(0, 0, width, height);\n\n      const grdWhite = ctx.createLinearGradient(0, 0, width, 0);\n      grdWhite.addColorStop(0, 'rgba(255,255,255,1)');\n      grdWhite.addColorStop(1, 'rgba(255,255,255,0)');\n      ctx.fillStyle = grdWhite;\n      ctx.fillRect(0, 0, width, height);\n\n      const grdBlack = ctx.createLinearGradient(0, 0, 0, height);\n      grdBlack.addColorStop(0, 'rgba(0,0,0,0)');\n      grdBlack.addColorStop(1, 'rgba(0,0,0,1)');\n      ctx.fillStyle = grdBlack;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n\n    {\n      ctx.save();\n      const {\n        x,\n        y,\n        width,\n        height,\n      } = strip;\n      ctx.translate(x, y);\n      const grd = ctx.createLinearGradient(0, 0, 0, height);\n      [\n        '255,0,0',\n        '255,0,255',\n        '0,0,255',\n        '0,255,255',\n        '0,255,0',\n        '255,255,0',\n        '255,0,0',\n      ].forEach((color, i) => {\n        grd.addColorStop(Math.min(0.17 * i, 1), `rgb(${color})`);\n      });\n      ctx.fillStyle = grd;\n      ctx.fillRect(0, 0, width, height);\n      ctx.restore();\n    }\n  };\n\n  onMount(() => {\n    ctx = canvas.getContext('2d');\n    ctx.imageSmoothingEnabled = false;\n  });\n\n  let lastArea;\n  $: if (ctx && $colors.area !== lastArea) {\n    lastArea = $colors.area;\n    draw();\n  }\n\n  let isPicking = false;\n  const onMouseMove = ({ clientX, clientY }) => {\n    if (!isPicking) {\n      return;\n    }\n    const rect = canvas.getBoundingClientRect();\n    const pointer = {\n      x: ((clientX - rect.left) / (rect.right - rect.left)) * width,\n      y: ((clientY - rect.top) / (rect.bottom - rect.top)) * height,\n    };\n    for (let i = 0; i < 2; i += 1) {\n      const {\n        x,\n        y,\n        width,\n        height,\n      } = i === 0 ? area : strip;\n      if (\n        pointer.x >= x\n        && pointer.x <= x + width\n        && pointer.y >= y\n        && pointer.y <= y + height\n      ) {\n        const imageData = ctx.getImageData(pointer.x, pointer.y, 1, 1).data;\n        colors.setColor([\n          imageData[0],\n          imageData[1],\n          imageData[2],\n          $colors.current[3],\n        ], i === 1);\n        break;\n      }\n    }\n  };\n  const onMouseDown = (e) => {\n    isPicking = true;\n    onMouseMove(e);\n  };\n  const onMouseUp = () => {\n    isPicking = false;\n  };\n\n  $: current = enableOpacity ? $colors.current : [...$colors.current.slice(0, 3), 0xFF];\n  $: opacity = $colors.current[3];\n</script>\n\n<svelte:window on:blur={onMouseUp} on:mouseup={onMouseUp} />\n\n<colorpicker>\n  <tools>\n    <div><Color color={current} /></div>\n    <label>\n      Size:\n      <input\n        type=\"range\"\n        min={2}\n        max={6}\n        step={2}\n        value={$colors.brush}\n        on:change={({ target: { value } }) => { colors.setBrush(value); }}\n      />\n    </label>\n    <label>\n      Noise:\n      <input\n        type=\"range\"\n        min={0}\n        max={1}\n        step={0.01}\n        value={$colors.noise}\n        on:input={({ target: { value } }) => { colors.setNoise(value); }}\n      />\n    </label>\n    <label>\n      Opacity:\n      <input\n        disabled={!enableOpacity}\n        type=\"range\"\n        min={0}\n        max={0xFF}\n        step={1}\n        value={opacity}\n        on:input={({ target: { value } }) => { colors.setAlpha(value); }}\n      />\n    </label>\n  </tools>\n  <canvas\n    bind:this={canvas}\n    width={width}\n    height={height}\n    on:mousedown={onMouseDown}\n    on:mousemove={onMouseMove}\n  />\n  <palette>\n    {#each $colors.palette as rgba}\n      <div on:click={() => colors.setColor(rgba, true)}>\n        <Color\n          color={rgba}\n        />\n      </div>\n    {/each}\n  </palette>\n</colorpicker>\n\n<style>\n  colorpicker {\n    display: flex;\n    height: 100%;\n    background: #222;\n    flex-direction: column;\n  }\n\n  tools {\n    box-sizing: border-box;\n    padding: 0.75rem;\n    display: flex;\n    align-items: center;\n    justify-content: space-between;\n    border-bottom: 2px solid #111;\n  }\n\n  tools > div {\n    margin-right: 0.25rem;\n  }\n\n  tools > label {\n    display: flex;\n    align-items: center;\n  }\n\n  tools > label > input[type=\"range\"] {\n    width: 3rem;\n  }\n\n  canvas {\n    display: block;\n    background: #000;\n    border: 8px solid #222;\n    box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);\n  }\n\n  palette {\n    box-sizing: border-box;\n    padding: 1rem;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n    border-top: 2px solid #111;\n  }\n\n  palette > div {\n    margin: 0 0.25rem;\n  }\n</style>\n",
    "<script>\n  const keys = [\n    ['Left Click', 'Place block'],\n    ['Right Click', 'Remove block'],\n    ['Middle Click', 'Pick block'],\n    ['spacing'],\n    ['W', 'Forwards'],\n    ['A', 'Leftwards'],\n    ['S', 'Backwards'],\n    ['D', 'Rightwards'],\n    ['Shift', 'Downwards'],\n    ['Spacebar', 'Upwards'],\n    ['spacing'],\n    ['H', 'Toggle this help'],\n  ];\n\n  export let isLocked;\n  let isVisible = true;\n  const onKeydown = ({ keyCode, repeat, target }) => {\n    if (\n      !repeat\n      && keyCode === 72\n      && target.tagName.toUpperCase() !== 'INPUT'\n    ) {\n      isVisible = !isVisible;\n    }\n  };\n</script>\n\n<svelte:window on:keydown={onKeydown} />\n\n<help class:visible={isVisible && !isLocked}>\n  {#each keys as [key, action]}\n    {#if key === 'spacing'}\n      <spacing />\n    {:else}\n      <action>\n        <key>{key}</key>\n        <div>{action}</div>\n      </action>\n    {/if}\n  {/each}\n</help>\n\n<style>\n  help {\n    position: absolute;\n    top: 1rem;\n    right: 1rem;\n    pointer-events: none;\n    display: none;\n  }\n\n  help.visible {\n    display: block;\n  }\n\n  action {\n    display: flex;\n    align-items: center;\n    margin-bottom: 0.25rem;\n  }\n\n  key {\n    width: 80px;\n    white-space: nowrap;\n    margin-right: 1rem;\n    color: #aaa;\n  }\n\n  spacing {\n    display: block;\n    height: 1rem;\n  }\n</style>",
    "<script>\n  export let lighting;\n</script>\n\n<tools>\n  <label>\n    Sunlight:\n    <input\n      type=\"range\"\n      bind:value={$lighting.sunlight}\n      min={0}\n      max={1}\n      step={0.01}\n    />\n  </label>\n</tools>\n\n<style>\n  tools {\n    display: flex;\n    background: #222;\n    padding: 1rem 0.5rem;\n  }\n\n  tools > label {\n    display: flex;\n    align-items: center;\n    padding: 0 0.5rem;\n  }\n  \n  tools > label > input[type=\"range\"] {\n    display: flex;\n    align-items: center;\n    margin-left: 0.5rem;\n    width: 220px;\n  }\n</style>\n",
    "<script>\n  import { createEventDispatcher, onMount } from 'svelte';\n\n  const dispatch = createEventDispatcher();\n\n  export let brush;\n  export let color;\n  export let noise;\n  export let isTransparent;\n  export let pixels;\n  export let showGrid;\n\n  const size = { x: 16, y: 16 };\n  const scale = { x: 20, y: 20 };\n\n  let bg;\n  let canvas;\n  let ctx;\n  let grid;\n\n  onMount(() => {\n    ctx = canvas.getContext('2d');\n    ctx.imageSmoothingEnabled = false;\n    {\n      const ctx = bg.getContext('2d');\n      ctx.imageSmoothingEnabled = false;\n      const pScale = { x: scale.x * 0.5, y: scale.y * 0.5 };\n      for (let y = 0; y < size.y; y += 1) {\n        for (let x = 0; x < size.x; x += 1) {\n          const p = { x: x * scale.x, y: y * scale.y };\n          for (let py = 0; py < 2; py += 1) {\n            for (let px = 0; px < 2; px += 1) {\n              ctx.fillStyle = (px - py) % 2 === 0 ? 'rgb(255,255,255)' : 'rgb(204,204,204)';\n              ctx.fillRect(\n                p.x + px * pScale.x,\n                p.y + py * pScale.y,\n                pScale.x, pScale.y\n              );\n            }\n          }\n        }\n      }\n    }\n    {\n      const ctx = grid.getContext('2d');\n      ctx.imageSmoothingEnabled = false;\n      ctx.strokeStyle = 'rgba(25,25,25,0.25)';\n      for (let y = 0; y < size.y; y += 1) {\n        for (let x = 0; x < size.x; x += 1) {\n          ctx.strokeRect(\n            x * scale.x, y * scale.y,\n            scale.x, scale.y\n          );\n        }\n      }\n    }\n  });\n\n  let lastPixel;\n  let lastColor;\n  $: if (color !== lastColor) {\n    lastColor = color;\n    lastPixel = undefined;\n  }\n\n  let lastPixels;\n  let lastOpacity;\n  $: if (\n    ctx\n    && (\n      pixels !== lastPixels\n      || isTransparent !== lastOpacity\n    )\n  ) {\n    lastPixels = pixels;\n    lastOpacity = isTransparent;\n    lastPixel = undefined;\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    for (let i = 0, y = 0; y < size.y; y += 1) {\n      for (let x = 0; x < size.x; x += 1, i += 4) {\n        const alpha = isTransparent ? pixels[i + 3] / 0xFF : 1;\n        ctx.fillStyle = `rgba(${pixels[i]},${pixels[i + 1]},${pixels[i + 2]},${alpha})`;\n        ctx.fillRect(\n          x * scale.x, y * scale.y,\n          scale.x, scale.y\n        );\n      }\n    }\n  }\n\n  $: brushOffsets = [...Array(brush ** 2)]\n    .map((v, i) => ({ x: Math.floor(i % brush), y: Math.floor(i / brush) }))\n    .reduce((offsets, { x, y }) => {\n      const radius = brush * 0.5;\n      x -= radius;\n      y -= radius;\n      if (Math.sqrt((x ** 2) + (y ** 2)) < radius) {\n        offsets.push({ x, y });\n      }\n      return offsets;\n    }, []);\n\n  let isDrawing = false;\n  const onMouseMove = ({ clientX, clientY }) => {\n    if (!isDrawing) {\n      return;\n    }\n    const rect = canvas.getBoundingClientRect();\n    const x = Math.floor(((clientX - rect.left) / (rect.right - rect.left) * canvas.width) / scale.x);\n    const y = Math.floor(((clientY - rect.top) / (rect.bottom - rect.top) * canvas.height) / scale.y);\n    const pixel = ((size.x * y) + x) * 4;\n    if (pixel !== lastPixel) {\n      lastPixel = pixel;\n      brushOffsets.forEach((offset) => {\n        const px = offset.x + x;\n        const py = offset.y + y;\n        if (px < 0 || px >= size.x || py < 0 || py >= size.y) {\n          return;\n        }\n        const pixel = ((size.x * py) + px) * 4;\n        const rgba = [\n          ...color.slice(0, 3),\n          (isTransparent ? color[3] : 0xFF),\n        ];\n        if (noise) {\n          const intensity = ((color[0] + color[1] + color[2]) / 3) * noise * 2;\n          for (let i = 0; i < 3; i += 1) {\n            rgba[i] = Math.floor(rgba[i] + (Math.random() - 0.5) * intensity);\n          }\n        }\n        pixels[pixel] = rgba[0];\n        pixels[pixel + 1] = rgba[1];\n        pixels[pixel + 2] = rgba[2];\n        pixels[pixel + 3] = rgba[3];\n        ctx.fillStyle = `rgba(${rgba[0]},${rgba[1]},${rgba[2]},${rgba[3] / 0xFF})`;\n        if (isTransparent) {\n          ctx.clearRect(\n            px * scale.x,\n            py * scale.y,\n            scale.x, scale.y\n          );\n        }\n        ctx.fillRect(\n          px * scale.x,\n          py * scale.y,\n          scale.x, scale.y\n        );\n      });\n      dispatch('update', pixels);\n    }\n  };\n  const onMouseDown = (e) => {\n    isDrawing = true;\n    onMouseMove(e);\n  };\n  const onMouseUp = () => {\n    isDrawing = false;\n  };\n</script>\n\n<svelte:window on:blur={onMouseUp} on:mouseup={onMouseUp} />\n\n<pixels>\n  <canvas\n    bind:this={bg}\n    width={size.x * scale.x}\n    height={size.y * scale.y}\n  />\n  <canvas\n    class=\"pixels\"\n    bind:this={canvas}\n    width={size.x * scale.x}\n    height={size.y * scale.y}\n    on:mousedown={onMouseDown}\n    on:mousemove={onMouseMove}\n  />\n  <canvas\n    class=\"grid\"\n    class:visible={showGrid}\n    bind:this={grid}\n    width={size.x * scale.x}\n    height={size.y * scale.y}\n  />\n</pixels>\n\n<style>\n  pixels {\n    display: block;\n    position: relative;\n  }\n\n  canvas {\n    display: block;\n  }\n\n  canvas.pixels, canvas.grid {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n\n  canvas.grid {\n    display: none;\n    pointer-events: none;\n  }\n\n  canvas.grid.visible {\n    display: block;\n  }\n</style>\n",
    "<script>\n  import { onMount, onDestroy } from 'svelte';\n  import CodeMirror from 'codemirror';\n  import 'codemirror/mode/javascript/javascript';\n  import 'codemirror/lib/codemirror.css';\n  import 'codemirror/theme/monokai.css';\n\n  export let blocks;\n  export let script;\n\n  let textarea;\n  let codemirror;\n  let currentScript = $script;\n  onMount(() => {\n    codemirror = CodeMirror.fromTextArea(textarea, {\n      lineNumbers: true,\n      lineWrapping: true,\n      mode: 'javascript',\n      theme: 'monokai',\n      viewportMargin: Infinity,\n    });\n    codemirror.on('change', () => {\n      $script = codemirror.getValue();\n      currentScript = $script;\n    });\n  });\n\n  onDestroy(() => {\n    codemirror.toTextArea();\n  });\n  \n  $: if ($script !== currentScript) {\n    codemirror.setValue($script);\n  }\n\n  const onRun = () => blocks.runScript();\n</script>\n\n<code>\n  <textarea bind:this={textarea}>{$script}</textarea>\n</code>\n<tools>\n  <button on:click={onRun}>\n    Run\n  </button>\n</tools>\n\n<style>\n  code {\n    flex-grow: 1;\n  }\n\n  tools {\n    display: flex;\n    background: #222;\n    justify-content: center;\n    padding: 0.5rem 0;\n    border-top: 2px solid #111;\n  }\n\n  tools > button {\n    width: 150px;\n  }\n</style>\n",
    "<script>\n  import { onMount } from 'svelte';\n\n  export let isTransparent;\n  export let pixels;\n\n  const size = { x: 16, y: 16 };\n  const scale = { x: 4, y: 4 };\n\n  let bg;\n  let canvas;\n  let ctx;\n\n  onMount(() => {\n    ctx = canvas.getContext('2d');\n    ctx.imageSmoothingEnabled = false;\n    {\n      const ctx = bg.getContext('2d');\n      ctx.imageSmoothingEnabled = false;\n      const pScale = { x: scale.x * 0.5, y: scale.y * 0.5 };\n      for (let y = 0; y < size.y; y += 1) {\n        for (let x = 0; x < size.x; x += 1) {\n          const p = { x: x * scale.x, y: y * scale.y };\n          for (let py = 0; py < 2; py += 1) {\n            for (let px = 0; px < 2; px += 1) {\n              ctx.fillStyle = (px - py) % 2 === 0 ? 'rgb(255,255,255)' : 'rgb(204,204,204)';\n              ctx.fillRect(\n                p.x + px * pScale.x,\n                p.y + py * pScale.y,\n                pScale.x, pScale.y\n              );\n            }\n          }\n        }\n      }\n    }\n  });\n\n  $: if (ctx) {\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    for (let i = 0, y = 0; y < size.y; y += 1) {\n      for (let x = 0; x < size.x; x += 1, i += 4) {\n        const alpha = isTransparent ? pixels[i + 3] / 0xFF : 1;\n        ctx.fillStyle = `rgba(${pixels[i]},${pixels[i + 1]},${pixels[i + 2]},${alpha})`;\n        ctx.fillRect(\n          x * scale.x, y * scale.y,\n          scale.x, scale.y\n        );\n      }\n    }\n  }\n</script>\n\n<texture>\n  <canvas\n    bind:this={bg}\n    width={size.x * scale.x}\n    height={size.y * scale.y}\n  />\n  <canvas\n    bind:this={canvas}\n    class=\"pixels\"\n    width={size.x * scale.x}\n    height={size.y * scale.y}\n  />\n</texture>\n\n<style>\n  texture {\n    display: block;\n    position: relative;\n  }\n\n  canvas {\n    display: block;\n  }\n\n  canvas.pixels {\n    position: absolute;\n    top: 0;\n    left: 0;\n  }\n</style>\n",
    "<script>\n  export let blocks;\n\n  const onExport = () => blocks.gltf('model');\n  \n  const onLoad = () => blocks.load();\n\n  const onPhysics = () => blocks.computePhysics('physics');\n\n  const onReset = () => {\n    if (!confirm('Are you sure?')) {\n      return;\n    }\n    blocks.reset();\n  };\n\n  const onSave = () => blocks.save('blocks');\n</script>\n\n<tools>\n  <div>\n    <button on:click={onLoad}>\n      Load\n    </button>\n    <button on:click={onSave}>\n      Save\n    </button>\n    <button on:click={onReset}>\n      Reset\n    </button>\n  </div>\n  <div>\n    <button on:click={onExport}>\n      Export Model\n    </button>\n    <button on:click={onPhysics}>\n      Export Physics\n    </button>\n  </div>\n</tools>\n\n<style>\n  tools {\n    display: flex;\n    flex-direction: column;\n    background: #222;\n    padding: 0.5rem 0;\n  }\n\n  tools > div {\n    display: flex;\n    background: #222;\n    padding: 0.5rem;\n  }\n\n  button {\n    flex-grow: 1;\n    flex-shrink: 1;\n    margin: 0 0.5rem;\n  }\n</style>\n",
    "<script>\n  import Blocks from '../components/blocks.svelte';\n  import BlockTypes from '../components/blockTypes.svelte';\n  import BlockEditor from '../components/blockEditor.svelte';\n  import Lighting from '../components/lighting.svelte';\n  import ScriptEditor from '../components/scriptEditor.svelte';\n  import Tools from '../components/tools.svelte';\n  import BlockEditorStore from '../stores/blockEditor';\n  import BlockTypesStore from '../stores/blockTypes';\n  import ColorsStore from '../stores/colors';\n  import ScriptEditorStore from '../stores/scriptEditor';\n\n  const {\n    atlas,\n    lighting,\n    types,\n    textures,\n  } = BlockTypesStore();\n  const colors = ColorsStore();\n  const blockEditor = BlockEditorStore();\n  const script = ScriptEditorStore();\n\n  let blocks;\n  let selected = 0;\n</script>\n\n<wrapper>\n  <ui>\n   <heading>\n      Block Types\n      <button\n        on:click={() => {\n          types.create();\n          selected = $types.length - 1;\n          blockEditor.open(selected);\n        }}\n      >\n        &plus;\n      </button>\n    </heading>\n    <scroll>\n      <BlockTypes\n        bind:selected={selected}\n        editor={blockEditor}\n        textures={textures}\n        types={types}\n      />\n    </scroll>\n    <heading>\n      Lighting\n    </heading>\n    <Lighting lighting={lighting} />\n    <heading>\n      Tools\n    </heading>\n    <Tools blocks={blocks} />\n  </ui>\n  {#if $blockEditor !== undefined}\n    <ui class=\"blocksEditor\">\n      <heading>\n        <button\n          on:click={() => blockEditor.close()}\n        >\n          &times;\n        </button>\n      </heading>\n      <BlockEditor\n        editor={blockEditor}\n        colors={colors}\n        textures={textures}\n        types={types}\n      />\n    </ui>\n  {/if}\n  <viewport>\n    <Blocks\n      bind:this={blocks}\n      bind:selected={selected}\n      atlas={atlas}\n      editor={blockEditor}\n      lighting={lighting}\n      script={script}\n      types={types}\n    />\n  </viewport>\n  <ui class=\"scriptEditor\">\n    <heading>\n      Scripting\n    </heading>\n    <ScriptEditor\n      blocks={blocks}\n      script={script}\n    />\n  </ui>\n</wrapper>\n\n<style>\n  wrapper {\n    height: 100%;\n    display: flex;\n    overflow: hidden;\n  }\n\n  ui {\n    width: 320px;\n    display: flex;\n    flex-direction: column;\n    border-right: 2px solid #000;\n  }\n\n  ui.blocksEditor {\n    width: 336px;\n  }\n\n  ui.scriptEditor {\n    width: 480px;\n  }\n\n  scroll {\n    flex-grow: 1;\n    overflow-y: scroll;\n  }\n\n  heading {\n    display: flex;\n    align-items: center;\n    background: #333;\n    padding: 0.5rem 1rem;\n    border-top: 2px solid #111;\n    border-bottom: 2px solid #111;\n  }\n\n  heading > button {\n    margin-left: auto;\n    padding: 0.125rem 0.75rem;\n  }\n\n  viewport {\n    display: flex;\n    flex-grow: 1;\n    position: relative;\n    overflow: hidden;\n    cursor: pointer;\n  }\n</style>\n"
  ],
  "names": [],
  "mappings": "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"
}