!function(){"use strict";const t=self,e=16,s=80,o=15,n={type:0,light:1,sunlight:2,count:3},a=new Map,l={light:1,sunlight:1};let i;const h=(t,e)=>({x:t,z:e,voxels:new Uint8ClampedArray(20480*n.count),heightmap:new Uint8ClampedArray(256),hasPropagated:!1}),r=(t,e)=>{const s=`${t}:${e}`;let o=a.get(s);return o||(o={...h(t,e),key:s},a.set(s,o)),o},c=(t,o,a)=>(t*e*s+o*e+a)*n.count,x=t=>(s,o)=>{let n=t;const a=s<0||s>=e?Math.floor(s/e):0,l=o<0||o>=e?Math.floor(o/e):0;return(a||l)&&(n=r(t.x+a,t.z+l),s-=e*a,o-=e*l),{chunk:n,cx:s,cz:o}},u=[{x:1,y:0,z:0},{x:-1,y:0,z:0},{x:0,y:0,z:1},{x:0,y:0,z:-1},{x:0,y:1,z:0},{x:0,y:-1,z:0}],p=(t,a,l="light")=>{const h=x(t),r="sunlight"===l;for(;a.length;){const{x:t,y:x,z:p}=a.shift(),{chunk:f,cx:g,cz:y}=h(t,p),z=f.voxels[c(g,x,y)+n[l]];u.forEach((u=>{const f=x+u.y;if(f<0||f>=s)return;const g=t+u.x,y=p+u.z,m=z-(r&&-1===u.y&&z===o?0:1),{chunk:d,cx:v,cz:M}=h(g,y),k=c(v,f,M);var b;(b=d.voxels[k],!i[b].isTranslucent||r&&-1!==u.y&&z===o&&f>d.heightmap[v*e+M]||d.voxels[k+n[l]]>=m)||(d.voxels[k+n[l]]=m,a.push({x:g,y:f,z:y}))}))}},f=t=>{const a=[],l=[];for(let h=0;h<e;h+=1)for(let r=0;r<s;r+=1)for(let s=0;s<e;s+=1){const e=c(h,r,s),x=t.voxels[e];79===r&&i[x].isTranslucent?(t.voxels[e+n.sunlight]=o,l.push({x:h,y:79,z:s})):i[x].isLight&&(t.voxels[e+n.light]=o,a.push({x:h,y:r,z:s}))}p(t,a,"light"),p(t,l,"sunlight"),t.hasPropagated=!0},g=(t,e,a,l,i="light")=>{const h=x(t),{chunk:r,cx:f,cz:g}=h(e,l),y=c(f,a,g),z=[],m=[];m.push({x:e,y:a,z:l,light:r.voxels[y+n[i]]}),r.voxels[y+n[i]]=0;const d="sunlight"===i;for(;m.length;){const{x:t,y:e,z:a,light:l}=m.shift();u.forEach((r=>{const x=e+r.y;if(x<0||x>=s)return;const u=t+r.x,p=a+r.z,{chunk:f,cx:g,cz:y}=h(u,p),v=c(g,x,y),M=f.voxels[v+n[i]];0!==M&&(M<l||d&&-1===r.y&&l===o&&M===o?(m.push({x:u,y:x,z:p,light:M}),f.voxels[v+n[i]]=0):M>=l&&z.push({x:u,y:x,z:p}))}))}p(t,z,i)},y=({x:t,y:a,z:l,type:h})=>{const f=r(Math.floor(t/e),Math.floor(l/e));t-=e*f.x,l-=e*f.z;const{heightmap:y,voxels:z,hasPropagated:m}=f,d=c(t,a,l),v=z[d];z[d]=h;const M=t*e+l,k=y[M];if(h===i.air){if(a===k)for(let e=a-1;e>=0;e-=1)if(0===e||0!==z[c(t,e,l)]){y[M]=e;break}}else k<a&&(y[M]=a);if(m)if(i[v].isLight?g(f,t,a,l):i[v].isTranslucent&&!i[h].isTranslucent&&["light","sunlight"].forEach((e=>{0!==z[d+n[e]]&&g(f,t,a,l,e)})),i[h].isLight)z[d+n.light]=o,p(f,[{x:t,y:a,z:l}]);else if(i[h].isTranslucent&&!i[v].isTranslucent){const e=x(f);["light","sunlight"].forEach((h=>{const r=[];"sunlight"===h&&79===a?(z[d+n[h]]=o,r.push({x:t,y:a,z:l})):u.forEach((o=>{const x=a+o.y;if(x<0||x>=s)return;const u=t+o.x,p=l+o.z,{chunk:f,cx:g,cz:y}=e(u,p),z=c(g,x,y),{isLight:m,isTranslucent:d}=i[f.voxels[z]];0!==f.voxels[z+n[h]]&&(d||m&&"light"===h)&&r.push({x:u,y:x,z:p})})),p(f,r,h)}))}return f},z=({light:t,sunlight:e},s)=>s.map((s=>{let n=i[s[0].type].hasAO,a=i[s[1].type].hasAO,h=n&&a||i[s[2].type].hasAO;const r=[n,a,h].reduce(((t,e)=>t-(e?.1:0)),1);let c=1,x=t,u=e;return n=i[s[0].type].isTranslucent,a=i[s[1].type].isTranslucent,h=(n||a)&&i[s[2].type].isTranslucent,[n,a,h].forEach(((t,e)=>{t&&(x+=s[e].light,u+=s[e].sunlight,c+=1)})),Math.max(Math.max(x*l.light,u*l.sunlight)/c/o,.02)*r})),m={top:{type:0,light:0,sunlight:o},bottom:{type:0,light:0,sunlight:0}},d=(t,e)=>(i[t].isGhost||!i[e].isGhost)&&(!i[t].isCulled||!i[e].isCulled||(i[e].hasAlpha||i[e].hasBlending)&&(!(i[t].hasAlpha||i[t].hasBlending)||t!==e)),v=[{x:-1,z:-1},{x:0,z:-1},{x:1,z:-1},{x:-1,z:0},{x:1,z:0},{x:-1,z:1},{x:0,z:1},{x:1,z:1}],M=1/18,k=17/18,b=new Map,A=(t,a)=>{const h=r(t,a);b.has(h.key)||b.set(h.key,h),h.hasPropagated||f(h),v.forEach((({x:t,z:e})=>{const s=r(h.x+t,h.z+e);s.hasPropagated||f(s)}));const u=(t=>{const e=x(t);return(t,o,a)=>{if(o<0)return m.bottom;if(o>=s)return m.top;const{chunk:l,cx:i,cz:h}=e(t,a),r=c(i,o,h);return{type:l.voxels[r],light:l.voxels[r+n.light],sunlight:l.voxels[r+n.sunlight]}}})(h);return[...Array(5)].map(((t,s)=>{const n=["alpha","blending","ghost","opaque"].reduce(((t,e)=>(t[e]={color:[],position:[],uv:[],index:[],offset:0},t)),{}),a=(t,e,s,o,a,l,h)=>{const r=i[a].textures[h%6],c=[[r.from,h+k],[r.to,h+k],[r.to,h+M],[r.from,h+M]],x=[t,e,s,o];l[0]+l[2]<l[1]+l[3]&&(l.unshift(l.pop()),c.unshift(c.pop()),x.unshift(x.pop()));let u=n.opaque;i[a].hasAlpha?u=n.alpha:i[a].hasBlending?u=n.blending:i[a].isGhost&&(u=n.ghost),l.forEach((t=>u.color.push(t,t,t))),c.forEach((t=>u.uv.push(...t))),x.forEach((t=>u.position.push(...t))),[0,1,2,2,3,0].forEach((t=>u.index.push(u.offset+t))),u.offset+=4},h=(t,e,s,o)=>{const n=u(t,e+1,s),l=u(t,e-1,s),i=u(t,e,s+1),h=u(t,e,s-1),r=u(t-1,e,s),c=u(t+1,e,s);if(d(o,n.type)){const l=u(t,e+1,s-1),i=u(t+1,e+1,s),h=u(t-1,e+1,s),r=u(t,e+1,s+1);a([t,e+1,s+1],[t+1,e+1,s+1],[t+1,e+1,s],[t,e+1,s],o,z(n,[[h,r,u(t-1,e+1,s+1)],[i,r,u(t+1,e+1,s+1)],[i,l,u(t+1,e+1,s-1)],[h,l,u(t-1,e+1,s-1)]]),0)}if(d(o,l.type)){const n=u(t,e-1,s-1),i=u(t+1,e-1,s),h=u(t-1,e-1,s),r=u(t,e-1,s+1);a([t,e,s],[t+1,e,s],[t+1,e,s+1],[t,e,s+1],o,z(l,[[h,n,u(t-1,e-1,s-1)],[i,n,u(t+1,e-1,s-1)],[i,r,u(t+1,e-1,s+1)],[h,r,u(t-1,e-1,s+1)]]),1)}if(d(o,i.type)){const n=u(t+1,e,s+1),l=u(t-1,e,s+1),h=u(t,e+1,s+1),r=u(t,e-1,s+1);a([t,e,s+1],[t+1,e,s+1],[t+1,e+1,s+1],[t,e+1,s+1],o,z(i,[[l,r,u(t-1,e-1,s+1)],[n,r,u(t+1,e-1,s+1)],[n,h,u(t+1,e+1,s+1)],[l,h,u(t-1,e+1,s+1)]]),2)}if(d(o,h.type)){const n=u(t+1,e,s-1),l=u(t-1,e,s-1),i=u(t,e+1,s-1),r=u(t,e-1,s-1);a([t+1,e,s],[t,e,s],[t,e+1,s],[t+1,e+1,s],o,z(h,[[n,r,u(t+1,e-1,s-1)],[l,r,u(t-1,e-1,s-1)],[l,i,u(t-1,e+1,s-1)],[n,i,u(t+1,e+1,s-1)]]),3)}if(d(o,r.type)){const n=u(t-1,e,s-1),l=u(t-1,e,s+1),i=u(t-1,e+1,s),h=u(t-1,e-1,s);a([t,e,s],[t,e,s+1],[t,e+1,s+1],[t,e+1,s],o,z(r,[[n,h,u(t-1,e-1,s-1)],[l,h,u(t-1,e-1,s+1)],[l,i,u(t-1,e+1,s+1)],[n,i,u(t-1,e+1,s-1)]]),4)}if(d(o,c.type)){const n=u(t+1,e,s-1),l=u(t+1,e,s+1),i=u(t+1,e+1,s),h=u(t+1,e-1,s);a([t+1,e,s+1],[t+1,e,s],[t+1,e+1,s],[t+1,e+1,s+1],o,z(c,[[l,h,u(t+1,e-1,s+1)],[n,h,u(t+1,e-1,s-1)],[n,i,u(t+1,e+1,s-1)],[l,i,u(t+1,e+1,s+1)]]),5)}},r=(t,e,s,{type:n,light:i,sunlight:h},r)=>{const c=(()=>{const t=Math.max(Math.max(i*l.light,h*l.sunlight)/o,.02);return[...Array(4)].map((()=>t))})();a([t,e,s],[t+1,e,s+1],[t+1,e+1,s+1],[t,e+1,s],n,c,6),a([t,e,s+1],[t+1,e,s],[t+1,e+1,s],[t,e+1,s+1],n,c,6),r&&(a([t+1,e,s+1],[t,e,s],[t,e+1,s],[t+1,e+1,s+1],n,c,6),a([t+1,e,s],[t,e,s+1],[t,e+1,s+1],[t+1,e+1,s],n,c,6))},c=s*e,x=(s+1)*e;for(let t=0;t<e;t+=1)for(let s=c;s<x;s+=1)for(let o=0;o<e;o+=1){const e=u(t,s,o);if(0!==e.type)switch(i[e.type].model){case"cross":r(t,s,o,e,!i[e.type].hasAlpha);break;default:h(t,s,o,e.type)}}return["alpha","blending","ghost","opaque"].reduce(((t,e)=>{const{color:s,position:o,uv:a,index:l}=n[e];return t[e]={color:new Float32Array(s),position:new Uint8Array(o),uv:new Float32Array(a),index:new Uint16Array(l)},t}),{})}))},$=(()=>{let e;const s=new Map,o=()=>{[...s.values()].forEach((e=>((e,s)=>{const o=A(e,s);t.postMessage({type:"chunk",position:{x:e,z:s},subchunks:o},o.reduce(((t,e)=>(["alpha","blending","ghost","opaque"].forEach((s=>{s=e[s],t.push(s.color.buffer,s.position.buffer,s.uv.buffer,s.index.buffer)})),t)),[]))})(e.x,e.z))),s.clear()};return(t,n)=>{s.set(`${t}:${n}`,{x:t,z:n}),e&&clearTimeout(e),e=setTimeout(o,0)}})(),E=()=>{const t=[...b.values()];t.length?t.forEach((t=>$(t.x,t.z))):$(0,0)},w=({offset:t={x:0,y:0,z:0}})=>{const s=(t,s,a)=>{const h=`${Math.floor(t/e)}:${Math.floor(a/e)}`,r=b.get(h);if(!r)return 0;t-=e*r.x,a-=e*r.z;const x=c(t,s,a);return i[r.voxels[x]].isTranslucent?Math.floor(255*Math.max(r.voxels[x+n.light]*l.light,r.voxels[x+n.sunlight]*l.sunlight)/o):0},{min:a,max:h}=[...b.values()].reduce((({min:t,max:s},{x:o,z:n,heightmap:a})=>{const l=a.reduce(((t,e)=>Math.max(t,e)),0);return{min:{x:Math.min(t.x,o*e),y:0,z:Math.min(t.z,n*e)},max:{x:Math.max(s.x,(o+1)*e),y:Math.max(s.y,l),z:Math.max(s.z,(n+1)*e)}}}),{min:{x:1/0,y:0,z:1/0},max:{x:-1/0,y:0,z:-1/0}});h.y=Math.ceil((h.y+8)/e)*e;const r={x:h.x-a.x,y:h.y-a.y,z:h.z-a.z},x=Array(r.x*r.y*r.z);for(let t=a.z,e=0;t<h.z;t+=1)for(let o=a.y;o<h.y;o+=1)for(let n=a.x;n<h.x;n+=1,e+=1)x[e]=String.fromCharCode(s(n,o,t));return{data:btoa(x.join("")),origin:{x:a.x+t.x,y:a.y+t.y,z:a.z+t.z},size:r}},T=({includeGhost:t=!0,offset:o={x:0,y:0,z:0}})=>{const n=(o,n,a)=>{if(n<0||n>=s)return!1;const l=`${Math.floor(o/e)}:${Math.floor(a/e)}`,h=b.get(l);if(!h)return!1;o-=e*h.x,a-=e*h.z;const r=h.voxels[c(o,n,a)];return 0!==r&&(t||!i[r].isGhost)&&"cross"!==i[r].model},{min:a,max:l}=[...b.values()].reduce((({min:t,max:s},{x:o,z:n})=>({min:{x:Math.min(t.x,o*e),z:Math.min(t.z,n*e)},max:{x:Math.max(s.x,(o+1)*e),z:Math.max(s.z,(n+1)*e)}})),{min:{x:1/0,z:1/0},max:{x:-1/0,z:-1/0}}),h=[],r=new Map;for(let t=a.x;t<l.x;t+=1)for(let e=0;e<s;e+=1)for(let o=a.z;o<l.z;o+=1)if(n(t,e,o)&&!r.has(`${t}:${e}:${o}`)){const a={position:{x:t,y:e,z:o},size:{x:0,y:0,z:0}};h.push(a);for(let s=t+1;s<=l.x;s+=1)if(!n(s,e,o)||r.has(`${s}:${e}:${o}`)){a.size.x=s-t;break}a.size.y=s-e;for(let s=t;s<t+a.size.x;s+=1)for(let t=e+1;t<=e+a.size.y;t+=1)n(s,t,o)&&!r.has(`${s}:${t}:${o}`)||(a.size.y=t-e);a.size.z=l.z-o;for(let s=t;s<t+a.size.x;s+=1)for(let t=e;t<e+a.size.y;t+=1)for(let e=o+1;e<=o+a.size.z;e+=1)n(s,t,e)&&!r.has(`${s}:${t}:${e}`)||(a.size.z=e-o);for(let s=t;s<t+a.size.x;s+=1)for(let t=e;t<e+a.size.y;t+=1)for(let e=o;e<o+a.size.z;e+=1)r.set(`${s}:${t}:${e}`,!0)}return h.map((({position:t,size:e})=>[[t.x+o.x,t.y+o.y,t.z+o.z],[e.x,e.y,e.z]]))};t.addEventListener("message",(({data:h})=>{switch(h.type){case"types":{const t=i,e={alpha:0,blending:0,opaque:0};if(i=[{name:"Air",isLight:!1,isTranslucent:!0},...h.types.map((t=>{let s="opaque";t.hasAlpha?s="alpha":t.hasBlending&&(s="blending");const o="cross"===t.model,n=e[s];return t.isGhost||(e[s]+=o?1:3),{...t,hasAO:!o,isCulled:!o,isTranslucent:o||t.hasAlpha||t.hasBlending,textures:o?[n]:[n,n+2,n+1,n+1,n+1,n+1]}})).map((t=>({...t,textures:t.textures.map((s=>{let o="opaque";t.hasAlpha?o="alpha":t.hasBlending&&(o="blending");const n=1/Math.max(e[o],9),a=n/18,l=s*n+a;return{from:l,to:l+16*a}}))}))),{name:"Bedrock",hasAO:!0,isCulled:!0,isLight:!1,isTranslucent:!1}],m.bottom.type=i.length-1,t){let e=!1,s=!1;if(i.length<t.length)e=!0,s=t.map((({key:t})=>{if(!t)return 0;const e=i.findIndex((({key:e})=>e===t));return~e?e:0}));else{const s=t.length;for(let o=0;o<s;o+=1){const s=t[o],n=i[o];if(s.model!==n.model||s.hasAlpha!==n.hasAlpha||s.hasBlending!==n.hasBlending||s.isGhost!==n.isGhost||s.isLight!==n.isLight){e=!0;break}}}e&&([...a.values()].forEach((({key:t})=>{b.has(t)||a.delete(t)})),[...b.values()].forEach((t=>{const{voxels:e}=t,{length:a}=e;for(let t=0;t<a;t+=n.count)s&&(e[t]=s[e[t]]),e[t+n.light]=i[e[t]].isLight?o:0,e[t+n.sunlight]=0;t.hasPropagated=!1})))}E();break}case"lighting":l.light=h.channels.light,l.sunlight=h.channels.sunlight,E();break;case"clone":if(h.from.y>=0&&h.from.y<s&&h.to.y>=0&&h.to.y<s){const t=(({x:t,y:s,z:o},n)=>{const a=r(Math.floor(t/e),Math.floor(o/e));return t-=e*a.x,o-=e*a.z,y({...n,type:a.voxels[c(t,s,o)]})})(h.from,h.to);[t,...v.map((({x:e,z:s})=>({x:t.x+e,z:t.z+s})))].forEach((t=>$(t.x,t.z)))}break;case"update":if(h.update.y>=0&&h.update.y<s){const t=y(h.update);[t,...v.map((({x:e,z:s})=>({x:t.x+e,z:t.z+s})))].forEach((t=>$(t.x,t.z)))}break;case"pick":{const{block:o}=h;if(o.y>=0&&o.y<s){const s=r(Math.floor(o.x/e),Math.floor(o.z/e));o.x-=e*s.x,o.z-=e*s.z,t.postMessage({type:"pick",block:s.voxels[c(o.x,o.y,o.z)]})}break}case"load":a.clear(),b.clear(),i=void 0,h.chunks.forEach((({x:t,z:l,voxels:i})=>{const r=`${t}:${l}`,c=new Uint8ClampedArray(atob(i).split("").map((t=>t.charCodeAt(0)))),x=new Uint8ClampedArray(20480*n.count),u=new Uint8ClampedArray(256);for(let t=0,a=0,l=0;t<e;t+=1)for(let i=0;i<s;i+=1)for(let s=0;s<e;s+=1,a+=n.count,l+=1){const r=c[l];if(x[a]=r,0!==r){const l=t*e+s;u[l]<i&&(u[l]=i),h.types[r-1].isLight&&(x[a+n.light]=o)}}const p={x:t,z:l,voxels:x,heightmap:u,hasPropagated:!1,key:r};a.set(r,p),b.set(r,p)}));break;case"save":t.postMessage({type:"save",chunks:[...b.values()].map((({x:t,z:e,voxels:s})=>{const o=new Uint8ClampedArray(20480),{length:a}=s;for(let t=0,e=0;t<a;t+=1,e+=n.count)o[t]=s[e];return{x:t,z:e,voxels:btoa(String.fromCharCode.apply(null,o))}}))});break;case"computeLightmap":t.postMessage({type:"lightmap",lightmap:w(h)});break;case"computePhysics":t.postMessage({type:"physics",boxes:T(h)});break;case"reset":a.clear(),b.clear()}}))}();
//# sourceMappingURL=blocks.worker.js.map
